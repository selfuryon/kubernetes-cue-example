// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/hashicorp/vault-secrets-operator/api/v1beta1

package v1beta1

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

// VaultAuthConfigKubernetes provides VaultAuth configuration options needed for authenticating to Vault.
#VaultAuthConfigKubernetes: {
	// Role to use for authenticating to Vault.
	role: string @go(Role)

	// ServiceAccount to use when authenticating to Vault's
	// authentication backend. This must reside in the consuming secret's (VDS/VSS/PKI) namespace.
	serviceAccount: string @go(ServiceAccount)

	// TokenAudiences to include in the ServiceAccount token.
	audiences?: [...string] @go(TokenAudiences,[]string)

	// TokenExpirationSeconds to set the ServiceAccount token.
	// +kubebuilder:default=600
	// +kubebuilder:validation:Minimum=600
	tokenExpirationSeconds?: int64 @go(TokenExpirationSeconds)
}

// VaultAuthConfigJWT provides VaultAuth configuration options needed for authenticating to Vault.
#VaultAuthConfigJWT: {
	// Role to use for authenticating to Vault.
	role: string @go(Role)

	// SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
	// provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must
	// have a key named `jwt` which holds the JWT token.
	secretRef?: string @go(SecretRef)

	// ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's
	// JWT authentication backend.
	serviceAccount?: string @go(ServiceAccount)

	// TokenAudiences to include in the ServiceAccount token.
	audiences?: [...string] @go(TokenAudiences,[]string)

	// TokenExpirationSeconds to set the ServiceAccount token.
	// +kubebuilder:default=600
	// +kubebuilder:validation:Minimum=600
	tokenExpirationSeconds?: int64 @go(TokenExpirationSeconds)
}

// VaultAuthConfigAppRole provides VaultAuth configuration options needed for authenticating to
// Vault via an AppRole AuthMethod.
#VaultAuthConfigAppRole: {
	// RoleID of the AppRole Role to use for authenticating to Vault.
	roleId: string @go(RoleID)

	// SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which
	// provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the
	// AppRole Role's secretID.
	secretRef: string @go(SecretRef)
}

// VaultAuthConfigAWS provides VaultAuth configuration options needed for
// authenticating to Vault via an AWS AuthMethod. Will use creds from
// `SecretRef` or `IRSAServiceAccount` if provided, in that order. If neither
// are provided, the underlying node role or instance profile will be used to
// authenticate to Vault.
#VaultAuthConfigAWS: {
	// Vault role to use for authenticating
	role: string @go(Role)

	// AWS Region to use for signing the authentication request
	region?: string @go(Region)

	// The Vault header value to include in the STS signing request
	headerValue?: string @go(HeaderValue)

	// The role session name to use when creating a webidentity provider
	sessionName?: string @go(SessionName)

	// The STS endpoint to use; if not set will use the default
	stsEndpoint?: string @go(STSEndpoint)

	// The IAM endpoint to use; if not set will use the default
	iamEndpoint?: string @go(IAMEndpoint)

	// SecretRef is the name of a Kubernetes Secret in the consumer's (VDS/VSS/PKI) namespace
	// which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`,
	// `session_token`
	secretRef?: string @go(SecretRef)

	// IRSAServiceAccount name to use with IAM Roles for Service Accounts
	// (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This
	// ServiceAccount will be checked for other EKS annotations:
	// eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
	irsaServiceAccount?: string @go(IRSAServiceAccount)
}

// VaultAuthConfigGCP provides VaultAuth configuration options needed for
// authenticating to Vault via a GCP AuthMethod, using workload identity
#VaultAuthConfigGCP: {
	// Vault role to use for authenticating
	role: string @go(Role)

	// WorkloadIdentityServiceAccount is the name of a Kubernetes service
	// account (in the same Kubernetes namespace as the Vault*Secret referencing
	// this resource) which has been configured for workload identity in GKE.
	// Should be annotated with "iam.gke.io/gcp-service-account".
	workloadIdentityServiceAccount: string @go(WorkloadIdentityServiceAccount)

	// GCP Region of the GKE cluster's identity provider. Defaults to the region
	// returned from the operator pod's local metadata server.
	region?: string @go(Region)

	// GKE cluster name. Defaults to the cluster-name returned from the operator
	// pod's local metadata server.
	clusterName?: string @go(ClusterName)

	// GCP project ID. Defaults to the project-id returned from the operator
	// pod's local metadata server.
	projectID?: string @go(ProjectID)
}

// VaultAuthSpec defines the desired state of VaultAuth
#VaultAuthSpec: {
	// VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace,
	// eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to
	// namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the
	// Operator will default to the `default` VaultConnection, configured in the operator's namespace.
	vaultConnectionRef?: string @go(VaultConnectionRef)

	// Namespace to auth to in Vault
	namespace?: string @go(Namespace)

	// AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod.
	// This field allows administrators to customize which Kubernetes namespaces are authorized to
	// use with this AuthMethod. While Vault will still enforce its own rules, this has the added
	// configurability of restricting which VaultAuthMethods can be used by which namespaces.
	// Accepted values:
	// []{"*"} - wildcard, all namespaces.
	// []{"a", "b"} - list of namespaces.
	// unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this
	// is the default behavior.
	allowedNamespaces?: [...string] @go(AllowedNamespaces,[]string)

	// Method to use when authenticating to Vault.
	// +kubebuilder:validation:Enum=kubernetes;jwt;appRole;aws;gcp
	method: string @go(Method)

	// Mount to use when authenticating to auth method.
	mount: string @go(Mount)

	// Params to use when authenticating to Vault
	params?: {[string]: string} @go(Params,map[string]string)

	// Headers to be included in all Vault requests.
	headers?: {[string]: string} @go(Headers,map[string]string)

	// Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
	kubernetes?: null | #VaultAuthConfigKubernetes @go(Kubernetes,*VaultAuthConfigKubernetes)

	// AppRole specific auth configuration, requires that the Method be set to `appRole`.
	appRole?: null | #VaultAuthConfigAppRole @go(AppRole,*VaultAuthConfigAppRole)

	// JWT specific auth configuration, requires that the Method be set to `jwt`.
	jwt?: null | #VaultAuthConfigJWT @go(JWT,*VaultAuthConfigJWT)

	// AWS specific auth configuration, requires that Method be set to `aws`.
	aws?: null | #VaultAuthConfigAWS @go(AWS,*VaultAuthConfigAWS)

	// GCP specific auth configuration, requires that Method be set to `gcp`.
	gcp?: null | #VaultAuthConfigGCP @go(GCP,*VaultAuthConfigGCP)

	// StorageEncryption provides the necessary configuration to encrypt the client storage cache.
	// This should only be configured when client cache persistence with encryption is enabled.
	// This is done by passing setting the manager's commandline argument
	// --client-cache-persistence-model=direct-encrypted. Typically, there should only ever
	// be one VaultAuth configured with StorageEncryption in the Cluster, and it should have
	// the label: cacheStorageEncryption=true
	storageEncryption?: null | #StorageEncryption @go(StorageEncryption,*StorageEncryption)
}

// VaultAuthStatus defines the observed state of VaultAuth
#VaultAuthStatus: {
	// Valid auth mechanism.
	valid: bool   @go(Valid)
	error: string @go(Error)
}

// VaultAuth is the Schema for the vaultauths API
#VaultAuth: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #VaultAuthSpec     @go(Spec)
	status?:   #VaultAuthStatus   @go(Status)
}

// StorageEncryption provides the necessary configuration need to encrypt the storage cache
// entries using Vault's Transit engine.
#StorageEncryption: {
	// Mount path of the Transit engine in Vault.
	mount: string @go(Mount)

	// KeyName to use for encrypt/decrypt operations via Vault Transit.
	keyName: string @go(KeyName)
}

// VaultAuthList contains a list of VaultAuth
#VaultAuthList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VaultAuth] @go(Items,[]VaultAuth)
}
