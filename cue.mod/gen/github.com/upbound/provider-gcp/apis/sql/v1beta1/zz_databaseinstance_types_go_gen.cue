// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/sql/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#ActiveDirectoryConfigInitParameters: {
	// The domain name for the active directory (e.g., mydomain.com).
	// Can only be used with SQL Server.
	domain?: null | string @go(Domain,*string)
}

#ActiveDirectoryConfigObservation: {
	// The domain name for the active directory (e.g., mydomain.com).
	// Can only be used with SQL Server.
	domain?: null | string @go(Domain,*string)
}

#ActiveDirectoryConfigParameters: {
	// The domain name for the active directory (e.g., mydomain.com).
	// Can only be used with SQL Server.
	// +kubebuilder:validation:Optional
	domain?: null | string @go(Domain,*string)
}

#AdvancedMachineFeaturesInitParameters: {
	// The number of threads per core. The value of this flag can be 1 or 2. To disable SMT, set this flag to 1. Only available in Cloud SQL for SQL Server instances. See smt for more details.
	threadsPerCore?: null | float64 @go(ThreadsPerCore,*float64)
}

#AdvancedMachineFeaturesObservation: {
	// The number of threads per core. The value of this flag can be 1 or 2. To disable SMT, set this flag to 1. Only available in Cloud SQL for SQL Server instances. See smt for more details.
	threadsPerCore?: null | float64 @go(ThreadsPerCore,*float64)
}

#AdvancedMachineFeaturesParameters: {
	// The number of threads per core. The value of this flag can be 1 or 2. To disable SMT, set this flag to 1. Only available in Cloud SQL for SQL Server instances. See smt for more details.
	// +kubebuilder:validation:Optional
	threadsPerCore?: null | float64 @go(ThreadsPerCore,*float64)
}

#AuthorizedNetworksInitParameters: {
	// The RFC 3339
	// formatted date time string indicating when this whitelist expires.
	expirationTime?: null | string @go(ExpirationTime,*string)

	// A name for this whitelist entry.
	name?: null | string @go(Name,*string)

	// A CIDR notation IPv4 or IPv6 address that is allowed to
	// access this instance. Must be set even if other two attributes are not for
	// the whitelist to become active.
	value?: null | string @go(Value,*string)
}

#AuthorizedNetworksObservation: {
	// The RFC 3339
	// formatted date time string indicating when this whitelist expires.
	expirationTime?: null | string @go(ExpirationTime,*string)

	// A name for this whitelist entry.
	name?: null | string @go(Name,*string)

	// A CIDR notation IPv4 or IPv6 address that is allowed to
	// access this instance. Must be set even if other two attributes are not for
	// the whitelist to become active.
	value?: null | string @go(Value,*string)
}

#AuthorizedNetworksParameters: {
	// The RFC 3339
	// formatted date time string indicating when this whitelist expires.
	// +kubebuilder:validation:Optional
	expirationTime?: null | string @go(ExpirationTime,*string)

	// A name for this whitelist entry.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// A CIDR notation IPv4 or IPv6 address that is allowed to
	// access this instance. Must be set even if other two attributes are not for
	// the whitelist to become active.
	// +kubebuilder:validation:Optional
	value?: null | string @go(Value,*string)
}

#BackupConfigurationInitParameters: {
	// Backup retention settings. The configuration is detailed below.
	backupRetentionSettings?: [...#BackupRetentionSettingsInitParameters] @go(BackupRetentionSettings,[]BackupRetentionSettingsInitParameters)

	// True if binary logging is enabled.
	// Can only be used with MySQL.
	binaryLogEnabled?: null | bool @go(BinaryLogEnabled,*bool)

	// True if backup configuration is enabled.
	enabled?: null | bool @go(Enabled,*bool)

	// The region where the backup will be stored
	location?: null | string @go(Location,*string)

	// True if Point-in-time recovery is enabled. Will restart database if enabled after instance creation. Valid only for PostgreSQL and SQL Server instances.
	pointInTimeRecoveryEnabled?: null | bool @go(PointInTimeRecoveryEnabled,*bool)

	// HH:MM format time indicating when backup
	// configuration starts.
	startTime?: null | string @go(StartTime,*string)

	// The number of days of transaction logs we retain for point in time restore, from 1-7. For PostgreSQL Enterprise Plus instances, the number of days of retained transaction logs can be set from 1 to 35.
	transactionLogRetentionDays?: null | float64 @go(TransactionLogRetentionDays,*float64)
}

#BackupConfigurationObservation: {
	// Backup retention settings. The configuration is detailed below.
	backupRetentionSettings?: [...#BackupRetentionSettingsObservation] @go(BackupRetentionSettings,[]BackupRetentionSettingsObservation)

	// True if binary logging is enabled.
	// Can only be used with MySQL.
	binaryLogEnabled?: null | bool @go(BinaryLogEnabled,*bool)

	// True if backup configuration is enabled.
	enabled?: null | bool @go(Enabled,*bool)

	// The region where the backup will be stored
	location?: null | string @go(Location,*string)

	// True if Point-in-time recovery is enabled. Will restart database if enabled after instance creation. Valid only for PostgreSQL and SQL Server instances.
	pointInTimeRecoveryEnabled?: null | bool @go(PointInTimeRecoveryEnabled,*bool)

	// HH:MM format time indicating when backup
	// configuration starts.
	startTime?: null | string @go(StartTime,*string)

	// The number of days of transaction logs we retain for point in time restore, from 1-7. For PostgreSQL Enterprise Plus instances, the number of days of retained transaction logs can be set from 1 to 35.
	transactionLogRetentionDays?: null | float64 @go(TransactionLogRetentionDays,*float64)
}

#BackupConfigurationParameters: {
	// Backup retention settings. The configuration is detailed below.
	// +kubebuilder:validation:Optional
	backupRetentionSettings?: [...#BackupRetentionSettingsParameters] @go(BackupRetentionSettings,[]BackupRetentionSettingsParameters)

	// True if binary logging is enabled.
	// Can only be used with MySQL.
	// +kubebuilder:validation:Optional
	binaryLogEnabled?: null | bool @go(BinaryLogEnabled,*bool)

	// True if backup configuration is enabled.
	// +kubebuilder:validation:Optional
	enabled?: null | bool @go(Enabled,*bool)

	// The region where the backup will be stored
	// +kubebuilder:validation:Optional
	location?: null | string @go(Location,*string)

	// True if Point-in-time recovery is enabled. Will restart database if enabled after instance creation. Valid only for PostgreSQL and SQL Server instances.
	// +kubebuilder:validation:Optional
	pointInTimeRecoveryEnabled?: null | bool @go(PointInTimeRecoveryEnabled,*bool)

	// HH:MM format time indicating when backup
	// configuration starts.
	// +kubebuilder:validation:Optional
	startTime?: null | string @go(StartTime,*string)

	// The number of days of transaction logs we retain for point in time restore, from 1-7. For PostgreSQL Enterprise Plus instances, the number of days of retained transaction logs can be set from 1 to 35.
	// +kubebuilder:validation:Optional
	transactionLogRetentionDays?: null | float64 @go(TransactionLogRetentionDays,*float64)
}

#BackupRetentionSettingsInitParameters: {
	// Depending on the value of retention_unit, this is used to determine if a backup needs to be deleted. If retention_unit
	// is 'COUNT', we will retain this many backups.
	retainedBackups?: null | float64 @go(RetainedBackups,*float64)

	// The unit that 'retained_backups' represents. Defaults to COUNT.
	retentionUnit?: null | string @go(RetentionUnit,*string)
}

#BackupRetentionSettingsObservation: {
	// Depending on the value of retention_unit, this is used to determine if a backup needs to be deleted. If retention_unit
	// is 'COUNT', we will retain this many backups.
	retainedBackups?: null | float64 @go(RetainedBackups,*float64)

	// The unit that 'retained_backups' represents. Defaults to COUNT.
	retentionUnit?: null | string @go(RetentionUnit,*string)
}

#BackupRetentionSettingsParameters: {
	// Depending on the value of retention_unit, this is used to determine if a backup needs to be deleted. If retention_unit
	// is 'COUNT', we will retain this many backups.
	// +kubebuilder:validation:Optional
	retainedBackups?: null | float64 @go(RetainedBackups,*float64)

	// The unit that 'retained_backups' represents. Defaults to COUNT.
	// +kubebuilder:validation:Optional
	retentionUnit?: null | string @go(RetentionUnit,*string)
}

#CloneInitParameters: {
	// The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the cloned instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
	allocatedIpRange?: null | string @go(AllocatedIPRange,*string)

	// (SQL Server only, use with point_in_time) Clone only the specified databases from the source instance. Clone all databases if empty.
	databaseNames?: [...null | string] @go(DatabaseNames,[]*string)

	// The timestamp of the point in time that should be restored.
	pointInTime?: null | string @go(PointInTime,*string)

	// Name of the source instance which will be cloned.
	sourceInstanceName?: null | string @go(SourceInstanceName,*string)
}

#CloneObservation: {
	// The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the cloned instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
	allocatedIpRange?: null | string @go(AllocatedIPRange,*string)

	// (SQL Server only, use with point_in_time) Clone only the specified databases from the source instance. Clone all databases if empty.
	databaseNames?: [...null | string] @go(DatabaseNames,[]*string)

	// The timestamp of the point in time that should be restored.
	pointInTime?: null | string @go(PointInTime,*string)

	// Name of the source instance which will be cloned.
	sourceInstanceName?: null | string @go(SourceInstanceName,*string)
}

#CloneParameters: {
	// The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the cloned instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
	// +kubebuilder:validation:Optional
	allocatedIpRange?: null | string @go(AllocatedIPRange,*string)

	// (SQL Server only, use with point_in_time) Clone only the specified databases from the source instance. Clone all databases if empty.
	// +kubebuilder:validation:Optional
	databaseNames?: [...null | string] @go(DatabaseNames,[]*string)

	// The timestamp of the point in time that should be restored.
	// +kubebuilder:validation:Optional
	pointInTime?: null | string @go(PointInTime,*string)

	// Name of the source instance which will be cloned.
	// +kubebuilder:validation:Optional
	sourceInstanceName?: null | string @go(SourceInstanceName,*string)
}

#DataCacheConfigInitParameters: {
	// Whether data cache is enabled for the instance. Defaults to false
	// Can only be used with MYSQL.
	dataCacheEnabled?: null | bool @go(DataCacheEnabled,*bool)
}

#DataCacheConfigObservation: {
	// Whether data cache is enabled for the instance. Defaults to false
	// Can only be used with MYSQL.
	dataCacheEnabled?: null | bool @go(DataCacheEnabled,*bool)
}

#DataCacheConfigParameters: {
	// Whether data cache is enabled for the instance. Defaults to false
	// Can only be used with MYSQL.
	// +kubebuilder:validation:Optional
	dataCacheEnabled?: null | bool @go(DataCacheEnabled,*bool)
}

#DatabaseFlagsInitParameters: {
	// A name for this whitelist entry.
	name?: null | string @go(Name,*string)

	// A CIDR notation IPv4 or IPv6 address that is allowed to
	// access this instance. Must be set even if other two attributes are not for
	// the whitelist to become active.
	value?: null | string @go(Value,*string)
}

#DatabaseFlagsObservation: {
	// A name for this whitelist entry.
	name?: null | string @go(Name,*string)

	// A CIDR notation IPv4 or IPv6 address that is allowed to
	// access this instance. Must be set even if other two attributes are not for
	// the whitelist to become active.
	value?: null | string @go(Value,*string)
}

#DatabaseFlagsParameters: {
	// A name for this whitelist entry.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// A CIDR notation IPv4 or IPv6 address that is allowed to
	// access this instance. Must be set even if other two attributes are not for
	// the whitelist to become active.
	// +kubebuilder:validation:Optional
	value?: null | string @go(Value,*string)
}

#DatabaseInstanceInitParameters: {
	// The context needed to create this instance as a clone of another instance. The
	// configuration is detailed below.
	clone?: [...#CloneInitParameters] @go(Clone,[]CloneInitParameters)

	// The MySQL, PostgreSQL or
	// SQL Server version to use. Supported values include MYSQL_5_6,
	// MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6,POSTGRES_10, POSTGRES_11,
	// POSTGRES_12, POSTGRES_13, POSTGRES_14, POSTGRES_15, SQLSERVER_2017_STANDARD,
	// SQLSERVER_2017_ENTERPRISE, SQLSERVER_2017_EXPRESS, SQLSERVER_2017_WEB.
	// SQLSERVER_2019_STANDARD, SQLSERVER_2019_ENTERPRISE, SQLSERVER_2019_EXPRESS,
	// SQLSERVER_2019_WEB.
	// Database Version Policies
	// includes an up-to-date reference of supported versions.
	databaseVersion?: null | string @go(DatabaseVersion,*string)

	// Defaults to true.
	deletionProtection?: null | bool @go(DeletionProtection,*bool)

	// The full path to the encryption key used for the CMEK disk encryption.
	// The provided key must be in the same region as the SQL instance.  In order
	// to use this feature, a special kind of service account must be created and
	// granted permission on this key.  This step can currently only be done
	// manually, please see this step.
	// That service account needs the Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter role on your
	// key - please see this step.
	encryptionKeyName?: null | string @go(EncryptionKeyName,*string)

	// The current software version on the instance. This attribute can not be set during creation. Refer to available_maintenance_versions attribute to see what maintenance_version are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a maintenance_version value that is older than the current one on the instance will be ignored.
	maintenanceVersion?: null | string @go(MaintenanceVersion,*string)

	// The name of the existing instance that will
	// act as the master in the replication setup. Note, this requires the master to
	// have binary_log_enabled set, as well as existing backups.
	masterInstanceName?: null | string @go(MasterInstanceName,*string)

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// The region the instance will sit in. If a region is not provided in the resource definition,
	// the provider region will be used instead.
	region?: null | string @go(Region,*string)

	// The configuration for replication. The
	// configuration is detailed below. Valid only for MySQL instances.
	replicaConfiguration?: [...#ReplicaConfigurationInitParameters] @go(ReplicaConfiguration,[]ReplicaConfigurationInitParameters)

	// The context needed to restore the database to a backup run. The configuration is detailed below. Adding or modifying this
	// block during resource creation/update will trigger the restore action after the resource is created/updated.
	restoreBackupContext?: [...#RestoreBackupContextInitParameters] @go(RestoreBackupContext,[]RestoreBackupContextInitParameters)

	// The settings to use for the database. The
	// configuration is detailed below. Required if clone is not set.
	settings?: [...#SettingsInitParameters] @go(Settings,[]SettingsInitParameters)
}

#DatabaseInstanceObservation: {
	// The list of all maintenance versions applicable on the instance.
	availableMaintenanceVersions?: [...null | string] @go(AvailableMaintenanceVersions,[]*string)

	// The context needed to create this instance as a clone of another instance. The
	// configuration is detailed below.
	clone?: [...#CloneObservation] @go(Clone,[]CloneObservation)

	// The connection name of the instance to be used in
	// connection strings. For example, when connecting with Cloud SQL Proxy.
	connectionName?: null | string @go(ConnectionName,*string)

	// The MySQL, PostgreSQL or
	// SQL Server version to use. Supported values include MYSQL_5_6,
	// MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6,POSTGRES_10, POSTGRES_11,
	// POSTGRES_12, POSTGRES_13, POSTGRES_14, POSTGRES_15, SQLSERVER_2017_STANDARD,
	// SQLSERVER_2017_ENTERPRISE, SQLSERVER_2017_EXPRESS, SQLSERVER_2017_WEB.
	// SQLSERVER_2019_STANDARD, SQLSERVER_2019_ENTERPRISE, SQLSERVER_2019_EXPRESS,
	// SQLSERVER_2019_WEB.
	// Database Version Policies
	// includes an up-to-date reference of supported versions.
	databaseVersion?: null | string @go(DatabaseVersion,*string)

	// Defaults to true.
	deletionProtection?: null | bool @go(DeletionProtection,*bool)

	// The full path to the encryption key used for the CMEK disk encryption.
	// The provided key must be in the same region as the SQL instance.  In order
	// to use this feature, a special kind of service account must be created and
	// granted permission on this key.  This step can currently only be done
	// manually, please see this step.
	// That service account needs the Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter role on your
	// key - please see this step.
	encryptionKeyName?: null | string @go(EncryptionKeyName,*string)

	// The first IPv4 address of any type assigned.
	firstIpAddress?: null | string @go(FirstIPAddress,*string)
	id?:             null | string @go(ID,*string)

	// The IPv4 address assigned.
	ipAddress?: [...#IPAddressObservation] @go(IPAddress,[]IPAddressObservation)

	// The type of the instance. The supported values are SQL_INSTANCE_TYPE_UNSPECIFIED, CLOUD_SQL_INSTANCE, ON_PREMISES_INSTANCE and READ_REPLICA_INSTANCE.
	instanceType?: null | string @go(InstanceType,*string)

	// The current software version on the instance. This attribute can not be set during creation. Refer to available_maintenance_versions attribute to see what maintenance_version are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a maintenance_version value that is older than the current one on the instance will be ignored.
	maintenanceVersion?: null | string @go(MaintenanceVersion,*string)

	// The name of the existing instance that will
	// act as the master in the replication setup. Note, this requires the master to
	// have binary_log_enabled set, as well as existing backups.
	masterInstanceName?: null | string @go(MasterInstanceName,*string)

	// The first private (PRIVATE) IPv4 address assigned.
	privateIpAddress?: null | string @go(PrivateIPAddress,*string)

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// The first public (PRIMARY) IPv4 address assigned.
	publicIpAddress?: null | string @go(PublicIPAddress,*string)

	// The region the instance will sit in. If a region is not provided in the resource definition,
	// the provider region will be used instead.
	region?: null | string @go(Region,*string)

	// The configuration for replication. The
	// configuration is detailed below. Valid only for MySQL instances.
	replicaConfiguration?: [...#ReplicaConfigurationObservation] @go(ReplicaConfiguration,[]ReplicaConfigurationObservation)

	// The context needed to restore the database to a backup run. The configuration is detailed below. Adding or modifying this
	// block during resource creation/update will trigger the restore action after the resource is created/updated.
	restoreBackupContext?: [...#RestoreBackupContextObservation] @go(RestoreBackupContext,[]RestoreBackupContextObservation)

	// The URI of the created resource.
	selfLink?: null | string @go(SelfLink,*string)
	serverCaCert?: [...#ServerCACertObservation] @go(ServerCACert,[]ServerCACertObservation)

	// The service account email address assigned to the
	// instance.
	serviceAccountEmailAddress?: null | string @go(ServiceAccountEmailAddress,*string)

	// The settings to use for the database. The
	// configuration is detailed below. Required if clone is not set.
	settings?: [...#SettingsObservation] @go(Settings,[]SettingsObservation)
}

#DatabaseInstanceParameters: {
	// The context needed to create this instance as a clone of another instance. The
	// configuration is detailed below.
	// +kubebuilder:validation:Optional
	clone?: [...#CloneParameters] @go(Clone,[]CloneParameters)

	// The MySQL, PostgreSQL or
	// SQL Server version to use. Supported values include MYSQL_5_6,
	// MYSQL_5_7, MYSQL_8_0, POSTGRES_9_6,POSTGRES_10, POSTGRES_11,
	// POSTGRES_12, POSTGRES_13, POSTGRES_14, POSTGRES_15, SQLSERVER_2017_STANDARD,
	// SQLSERVER_2017_ENTERPRISE, SQLSERVER_2017_EXPRESS, SQLSERVER_2017_WEB.
	// SQLSERVER_2019_STANDARD, SQLSERVER_2019_ENTERPRISE, SQLSERVER_2019_EXPRESS,
	// SQLSERVER_2019_WEB.
	// Database Version Policies
	// includes an up-to-date reference of supported versions.
	// +kubebuilder:validation:Optional
	databaseVersion?: null | string @go(DatabaseVersion,*string)

	// Defaults to true.
	// +kubebuilder:validation:Optional
	deletionProtection?: null | bool @go(DeletionProtection,*bool)

	// The full path to the encryption key used for the CMEK disk encryption.
	// The provided key must be in the same region as the SQL instance.  In order
	// to use this feature, a special kind of service account must be created and
	// granted permission on this key.  This step can currently only be done
	// manually, please see this step.
	// That service account needs the Cloud KMS > Cloud KMS CryptoKey Encrypter/Decrypter role on your
	// key - please see this step.
	// +kubebuilder:validation:Optional
	encryptionKeyName?: null | string @go(EncryptionKeyName,*string)

	// The current software version on the instance. This attribute can not be set during creation. Refer to available_maintenance_versions attribute to see what maintenance_version are available for upgrade. When this attribute gets updated, it will cause an instance restart. Setting a maintenance_version value that is older than the current one on the instance will be ignored.
	// +kubebuilder:validation:Optional
	maintenanceVersion?: null | string @go(MaintenanceVersion,*string)

	// The name of the existing instance that will
	// act as the master in the replication setup. Note, this requires the master to
	// have binary_log_enabled set, as well as existing backups.
	// +kubebuilder:validation:Optional
	masterInstanceName?: null | string @go(MasterInstanceName,*string)

	// The ID of the project in which the resource belongs. If it
	// is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// The region the instance will sit in. If a region is not provided in the resource definition,
	// the provider region will be used instead.
	// +kubebuilder:validation:Optional
	region?: null | string @go(Region,*string)

	// The configuration for replication. The
	// configuration is detailed below. Valid only for MySQL instances.
	// +kubebuilder:validation:Optional
	replicaConfiguration?: [...#ReplicaConfigurationParameters] @go(ReplicaConfiguration,[]ReplicaConfigurationParameters)

	// The context needed to restore the database to a backup run. The configuration is detailed below. Adding or modifying this
	// block during resource creation/update will trigger the restore action after the resource is created/updated.
	// +kubebuilder:validation:Optional
	restoreBackupContext?: [...#RestoreBackupContextParameters] @go(RestoreBackupContext,[]RestoreBackupContextParameters)

	// Initial root password. Can be updated. Required for MS SQL Server.
	// +kubebuilder:validation:Optional
	rootPasswordSecretRef?: null | v1.#SecretKeySelector @go(RootPasswordSecretRef,*v1.SecretKeySelector)

	// The settings to use for the database. The
	// configuration is detailed below. Required if clone is not set.
	// +kubebuilder:validation:Optional
	settings?: [...#SettingsParameters] @go(Settings,[]SettingsParameters)
}

#DenyMaintenancePeriodInitParameters: {
	// "deny maintenance period" end date. If the year of the end date is empty, the year of the start date also must be empty. In this case, it means the no maintenance interval recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
	endDate?: null | string @go(EndDate,*string)

	// "deny maintenance period" start date. If the year of the start date is empty, the year of the end date also must be empty. In this case, it means the deny maintenance period recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
	startDate?: null | string @go(StartDate,*string)

	// Time in UTC when the "deny maintenance period" starts on startDate and ends on endDate. The time is in format: HH:mm:SS, i.e., 00:00:00
	time?: null | string @go(Time,*string)
}

#DenyMaintenancePeriodObservation: {
	// "deny maintenance period" end date. If the year of the end date is empty, the year of the start date also must be empty. In this case, it means the no maintenance interval recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
	endDate?: null | string @go(EndDate,*string)

	// "deny maintenance period" start date. If the year of the start date is empty, the year of the end date also must be empty. In this case, it means the deny maintenance period recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
	startDate?: null | string @go(StartDate,*string)

	// Time in UTC when the "deny maintenance period" starts on startDate and ends on endDate. The time is in format: HH:mm:SS, i.e., 00:00:00
	time?: null | string @go(Time,*string)
}

#DenyMaintenancePeriodParameters: {
	// "deny maintenance period" end date. If the year of the end date is empty, the year of the start date also must be empty. In this case, it means the no maintenance interval recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
	// +kubebuilder:validation:Optional
	endDate?: null | string @go(EndDate,*string)

	// "deny maintenance period" start date. If the year of the start date is empty, the year of the end date also must be empty. In this case, it means the deny maintenance period recurs every year. The date is in format yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
	// +kubebuilder:validation:Optional
	startDate?: null | string @go(StartDate,*string)

	// Time in UTC when the "deny maintenance period" starts on startDate and ends on endDate. The time is in format: HH:mm:SS, i.e., 00:00:00
	// +kubebuilder:validation:Optional
	time?: null | string @go(Time,*string)
}

#IPAddressInitParameters: {
}

#IPAddressObservation: {
	// The IPv4 address assigned.
	ipAddress?: null | string @go(IPAddress,*string)

	// The time this IP address will be retired, in RFC
	// 3339 format.
	timeToRetire?: null | string @go(TimeToRetire,*string)

	// The type of this IP address.
	type?: null | string @go(Type,*string)
}

#IPAddressParameters: {
}

#IPConfigurationInitParameters: {
	// The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
	allocatedIpRange?: null | string @go(AllocatedIPRange,*string)
	authorizedNetworks?: [...#AuthorizedNetworksInitParameters] @go(AuthorizedNetworks,[]AuthorizedNetworksInitParameters)

	// Whether Google Cloud services such as BigQuery are allowed to access data in this Cloud SQL instance over a private IP connection. SQLSERVER database type is not supported.
	enablePrivatePathForGoogleCloudServices?: null | bool @go(EnablePrivatePathForGoogleCloudServices,*bool)

	// Whether this Cloud SQL instance should be assigned
	// a public IPV4 address. At least ipv4_enabled must be enabled or a
	// private_network must be configured.
	ipv4Enabled?: null | bool @go(IPv4Enabled,*bool)

	// Whether SSL connections over IP are enforced or not.
	requireSsl?: null | bool @go(RequireSSL,*bool)
}

#IPConfigurationObservation: {
	// The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
	allocatedIpRange?: null | string @go(AllocatedIPRange,*string)
	authorizedNetworks?: [...#AuthorizedNetworksObservation] @go(AuthorizedNetworks,[]AuthorizedNetworksObservation)

	// Whether Google Cloud services such as BigQuery are allowed to access data in this Cloud SQL instance over a private IP connection. SQLSERVER database type is not supported.
	enablePrivatePathForGoogleCloudServices?: null | bool @go(EnablePrivatePathForGoogleCloudServices,*bool)

	// Whether this Cloud SQL instance should be assigned
	// a public IPV4 address. At least ipv4_enabled must be enabled or a
	// private_network must be configured.
	ipv4Enabled?: null | bool @go(IPv4Enabled,*bool)

	// The VPC network from which the Cloud SQL
	// instance is accessible for private IP. For example, projects/myProject/global/networks/default.
	// Specifying a network enables private IP.
	// At least ipv4_enabled must be enabled or a private_network must be configured.
	// This setting can be updated, but it cannot be removed after it is set.
	privateNetwork?: null | string @go(PrivateNetwork,*string)

	// Whether SSL connections over IP are enforced or not.
	requireSsl?: null | bool @go(RequireSSL,*bool)
}

#IPConfigurationParameters: {
	// The name of the allocated ip range for the private ip CloudSQL instance. For example: "google-managed-services-default". If set, the instance ip will be created in the allocated range. The range name must comply with RFC 1035. Specifically, the name must be 1-63 characters long and match the regular expression a-z?.
	// +kubebuilder:validation:Optional
	allocatedIpRange?: null | string @go(AllocatedIPRange,*string)

	// +kubebuilder:validation:Optional
	authorizedNetworks?: [...#AuthorizedNetworksParameters] @go(AuthorizedNetworks,[]AuthorizedNetworksParameters)

	// Whether Google Cloud services such as BigQuery are allowed to access data in this Cloud SQL instance over a private IP connection. SQLSERVER database type is not supported.
	// +kubebuilder:validation:Optional
	enablePrivatePathForGoogleCloudServices?: null | bool @go(EnablePrivatePathForGoogleCloudServices,*bool)

	// Whether this Cloud SQL instance should be assigned
	// a public IPV4 address. At least ipv4_enabled must be enabled or a
	// private_network must be configured.
	// +kubebuilder:validation:Optional
	ipv4Enabled?: null | bool @go(IPv4Enabled,*bool)

	// The VPC network from which the Cloud SQL
	// instance is accessible for private IP. For example, projects/myProject/global/networks/default.
	// Specifying a network enables private IP.
	// At least ipv4_enabled must be enabled or a private_network must be configured.
	// This setting can be updated, but it cannot be removed after it is set.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/crossplane/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	privateNetwork?: null | string @go(PrivateNetwork,*string)

	// Reference to a Network in compute to populate privateNetwork.
	// +kubebuilder:validation:Optional
	privateNetworkRef?: null | v1.#Reference @go(PrivateNetworkRef,*v1.Reference)

	// Selector for a Network in compute to populate privateNetwork.
	// +kubebuilder:validation:Optional
	privateNetworkSelector?: null | v1.#Selector @go(PrivateNetworkSelector,*v1.Selector)

	// Whether SSL connections over IP are enforced or not.
	// +kubebuilder:validation:Optional
	requireSsl?: null | bool @go(RequireSSL,*bool)
}

#InsightsConfigInitParameters: {
	// True if Query Insights feature is enabled.
	queryInsightsEnabled?: null | bool @go(QueryInsightsEnabled,*bool)

	// Number of query execution plans captured by Insights per minute for all queries combined. Between 0 and 20. Default to 5.
	queryPlansPerMinute?: null | float64 @go(QueryPlansPerMinute,*float64)

	// Maximum query length stored in bytes. Between 256 and 4500. Default to 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
	queryStringLength?: null | float64 @go(QueryStringLength,*float64)

	// True if Query Insights will record application tags from query when enabled.
	recordApplicationTags?: null | bool @go(RecordApplicationTags,*bool)

	// True if Query Insights will record client address when enabled.
	recordClientAddress?: null | bool @go(RecordClientAddress,*bool)
}

#InsightsConfigObservation: {
	// True if Query Insights feature is enabled.
	queryInsightsEnabled?: null | bool @go(QueryInsightsEnabled,*bool)

	// Number of query execution plans captured by Insights per minute for all queries combined. Between 0 and 20. Default to 5.
	queryPlansPerMinute?: null | float64 @go(QueryPlansPerMinute,*float64)

	// Maximum query length stored in bytes. Between 256 and 4500. Default to 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
	queryStringLength?: null | float64 @go(QueryStringLength,*float64)

	// True if Query Insights will record application tags from query when enabled.
	recordApplicationTags?: null | bool @go(RecordApplicationTags,*bool)

	// True if Query Insights will record client address when enabled.
	recordClientAddress?: null | bool @go(RecordClientAddress,*bool)
}

#InsightsConfigParameters: {
	// True if Query Insights feature is enabled.
	// +kubebuilder:validation:Optional
	queryInsightsEnabled?: null | bool @go(QueryInsightsEnabled,*bool)

	// Number of query execution plans captured by Insights per minute for all queries combined. Between 0 and 20. Default to 5.
	// +kubebuilder:validation:Optional
	queryPlansPerMinute?: null | float64 @go(QueryPlansPerMinute,*float64)

	// Maximum query length stored in bytes. Between 256 and 4500. Default to 1024. Higher query lengths are more useful for analytical queries, but they also require more memory. Changing the query length requires you to restart the instance. You can still add tags to queries that exceed the length limit.
	// +kubebuilder:validation:Optional
	queryStringLength?: null | float64 @go(QueryStringLength,*float64)

	// True if Query Insights will record application tags from query when enabled.
	// +kubebuilder:validation:Optional
	recordApplicationTags?: null | bool @go(RecordApplicationTags,*bool)

	// True if Query Insights will record client address when enabled.
	// +kubebuilder:validation:Optional
	recordClientAddress?: null | bool @go(RecordClientAddress,*bool)
}

#LocationPreferenceInitParameters: {
	// A GAE application whose zone to remain
	// in. Must be in the same region as this instance.
	followGaeApplication?: null | string @go(FollowGaeApplication,*string)

	// The preferred Compute Engine zone for the secondary/failover.
	secondaryZone?: null | string @go(SecondaryZone,*string)

	// The preferred compute engine
	// zone.
	zone?: null | string @go(Zone,*string)
}

#LocationPreferenceObservation: {
	// A GAE application whose zone to remain
	// in. Must be in the same region as this instance.
	followGaeApplication?: null | string @go(FollowGaeApplication,*string)

	// The preferred Compute Engine zone for the secondary/failover.
	secondaryZone?: null | string @go(SecondaryZone,*string)

	// The preferred compute engine
	// zone.
	zone?: null | string @go(Zone,*string)
}

#LocationPreferenceParameters: {
	// A GAE application whose zone to remain
	// in. Must be in the same region as this instance.
	// +kubebuilder:validation:Optional
	followGaeApplication?: null | string @go(FollowGaeApplication,*string)

	// The preferred Compute Engine zone for the secondary/failover.
	// +kubebuilder:validation:Optional
	secondaryZone?: null | string @go(SecondaryZone,*string)

	// The preferred compute engine
	// zone.
	// +kubebuilder:validation:Optional
	zone?: null | string @go(Zone,*string)
}

#MaintenanceWindowInitParameters: {
	// Day of week (1-7), starting on Monday
	day?: null | float64 @go(Day,*float64)

	// Hour of day (0-23), ignored if day not set
	hour?: null | float64 @go(Hour,*float64)

	// Receive updates earlier (canary) or later
	// (stable)
	updateTrack?: null | string @go(UpdateTrack,*string)
}

#MaintenanceWindowObservation: {
	// Day of week (1-7), starting on Monday
	day?: null | float64 @go(Day,*float64)

	// Hour of day (0-23), ignored if day not set
	hour?: null | float64 @go(Hour,*float64)

	// Receive updates earlier (canary) or later
	// (stable)
	updateTrack?: null | string @go(UpdateTrack,*string)
}

#MaintenanceWindowParameters: {
	// Day of week (1-7), starting on Monday
	// +kubebuilder:validation:Optional
	day?: null | float64 @go(Day,*float64)

	// Hour of day (0-23), ignored if day not set
	// +kubebuilder:validation:Optional
	hour?: null | float64 @go(Hour,*float64)

	// Receive updates earlier (canary) or later
	// (stable)
	// +kubebuilder:validation:Optional
	updateTrack?: null | string @go(UpdateTrack,*string)
}

#PasswordValidationPolicyInitParameters: {
	// Checks if the password is a combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
	complexity?: null | string @go(Complexity,*string)

	// Prevents the use of the username in the password.
	disallowUsernameSubstring?: null | bool @go(DisallowUsernameSubstring,*bool)

	// Enables or disable the password validation policy.
	enablePasswordPolicy?: null | bool @go(EnablePasswordPolicy,*bool)

	// Specifies the minimum number of characters that the password must have.
	minLength?: null | float64 @go(MinLength,*float64)

	// Specifies the minimum duration after which you can change the password.
	passwordChangeInterval?: null | string @go(PasswordChangeInterval,*string)

	// Specifies the number of previous passwords that you can't reuse.
	reuseInterval?: null | float64 @go(ReuseInterval,*float64)
}

#PasswordValidationPolicyObservation: {
	// Checks if the password is a combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
	complexity?: null | string @go(Complexity,*string)

	// Prevents the use of the username in the password.
	disallowUsernameSubstring?: null | bool @go(DisallowUsernameSubstring,*bool)

	// Enables or disable the password validation policy.
	enablePasswordPolicy?: null | bool @go(EnablePasswordPolicy,*bool)

	// Specifies the minimum number of characters that the password must have.
	minLength?: null | float64 @go(MinLength,*float64)

	// Specifies the minimum duration after which you can change the password.
	passwordChangeInterval?: null | string @go(PasswordChangeInterval,*string)

	// Specifies the number of previous passwords that you can't reuse.
	reuseInterval?: null | float64 @go(ReuseInterval,*float64)
}

#PasswordValidationPolicyParameters: {
	// Checks if the password is a combination of lowercase, uppercase, numeric, and non-alphanumeric characters.
	// +kubebuilder:validation:Optional
	complexity?: null | string @go(Complexity,*string)

	// Prevents the use of the username in the password.
	// +kubebuilder:validation:Optional
	disallowUsernameSubstring?: null | bool @go(DisallowUsernameSubstring,*bool)

	// Enables or disable the password validation policy.
	// +kubebuilder:validation:Optional
	enablePasswordPolicy?: null | bool @go(EnablePasswordPolicy,*bool)

	// Specifies the minimum number of characters that the password must have.
	// +kubebuilder:validation:Optional
	minLength?: null | float64 @go(MinLength,*float64)

	// Specifies the minimum duration after which you can change the password.
	// +kubebuilder:validation:Optional
	passwordChangeInterval?: null | string @go(PasswordChangeInterval,*string)

	// Specifies the number of previous passwords that you can't reuse.
	// +kubebuilder:validation:Optional
	reuseInterval?: null | float64 @go(ReuseInterval,*float64)
}

#ReplicaConfigurationInitParameters: {
	// PEM representation of the trusted CA's x509
	// certificate.
	caCertificate?: null | string @go(CACertificate,*string)

	// PEM representation of the replica's x509
	// certificate.
	clientCertificate?: null | string @go(ClientCertificate,*string)

	// PEM representation of the replica's private key. The
	// corresponding public key in encoded in the client_certificate.
	clientKey?: null | string @go(ClientKey,*string)

	// The number of seconds
	// between connect retries. MySQL's default is 60 seconds.
	connectRetryInterval?: null | float64 @go(ConnectRetryInterval,*float64)

	// Path to a SQL file in GCS from which replica
	// instances are created. Format is gs://bucket/filename.
	dumpFilePath?: null | string @go(DumpFilePath,*string)

	// Specifies if the replica is the failover target.
	// If the field is set to true the replica will be designated as a failover replica.
	// If the master instance fails, the replica instance will be promoted as
	// the new master instance.
	// ~> NOTE: Not supported for Postgres database.
	failoverTarget?: null | bool @go(FailoverTarget,*bool)

	// Time in ms between replication
	// heartbeats.
	masterHeartbeatPeriod?: null | float64 @go(MasterHeartbeatPeriod,*float64)
	sslCipher?:             null | string  @go(SSLCipher,*string)

	// Username for replication connection.
	username?: null | string @go(Username,*string)

	// True if the master's common name
	// value is checked during the SSL handshake.
	verifyServerCertificate?: null | bool @go(VerifyServerCertificate,*bool)
}

#ReplicaConfigurationObservation: {
	// PEM representation of the trusted CA's x509
	// certificate.
	caCertificate?: null | string @go(CACertificate,*string)

	// PEM representation of the replica's x509
	// certificate.
	clientCertificate?: null | string @go(ClientCertificate,*string)

	// PEM representation of the replica's private key. The
	// corresponding public key in encoded in the client_certificate.
	clientKey?: null | string @go(ClientKey,*string)

	// The number of seconds
	// between connect retries. MySQL's default is 60 seconds.
	connectRetryInterval?: null | float64 @go(ConnectRetryInterval,*float64)

	// Path to a SQL file in GCS from which replica
	// instances are created. Format is gs://bucket/filename.
	dumpFilePath?: null | string @go(DumpFilePath,*string)

	// Specifies if the replica is the failover target.
	// If the field is set to true the replica will be designated as a failover replica.
	// If the master instance fails, the replica instance will be promoted as
	// the new master instance.
	// ~> NOTE: Not supported for Postgres database.
	failoverTarget?: null | bool @go(FailoverTarget,*bool)

	// Time in ms between replication
	// heartbeats.
	masterHeartbeatPeriod?: null | float64 @go(MasterHeartbeatPeriod,*float64)
	sslCipher?:             null | string  @go(SSLCipher,*string)

	// Username for replication connection.
	username?: null | string @go(Username,*string)

	// True if the master's common name
	// value is checked during the SSL handshake.
	verifyServerCertificate?: null | bool @go(VerifyServerCertificate,*bool)
}

#ReplicaConfigurationParameters: {
	// PEM representation of the trusted CA's x509
	// certificate.
	// +kubebuilder:validation:Optional
	caCertificate?: null | string @go(CACertificate,*string)

	// PEM representation of the replica's x509
	// certificate.
	// +kubebuilder:validation:Optional
	clientCertificate?: null | string @go(ClientCertificate,*string)

	// PEM representation of the replica's private key. The
	// corresponding public key in encoded in the client_certificate.
	// +kubebuilder:validation:Optional
	clientKey?: null | string @go(ClientKey,*string)

	// The number of seconds
	// between connect retries. MySQL's default is 60 seconds.
	// +kubebuilder:validation:Optional
	connectRetryInterval?: null | float64 @go(ConnectRetryInterval,*float64)

	// Path to a SQL file in GCS from which replica
	// instances are created. Format is gs://bucket/filename.
	// +kubebuilder:validation:Optional
	dumpFilePath?: null | string @go(DumpFilePath,*string)

	// Specifies if the replica is the failover target.
	// If the field is set to true the replica will be designated as a failover replica.
	// If the master instance fails, the replica instance will be promoted as
	// the new master instance.
	// ~> NOTE: Not supported for Postgres database.
	// +kubebuilder:validation:Optional
	failoverTarget?: null | bool @go(FailoverTarget,*bool)

	// Time in ms between replication
	// heartbeats.
	// +kubebuilder:validation:Optional
	masterHeartbeatPeriod?: null | float64 @go(MasterHeartbeatPeriod,*float64)

	// Password for the replication connection.
	// +kubebuilder:validation:Optional
	passwordSecretRef?: null | v1.#SecretKeySelector @go(PasswordSecretRef,*v1.SecretKeySelector)

	// +kubebuilder:validation:Optional
	sslCipher?: null | string @go(SSLCipher,*string)

	// Username for replication connection.
	// +kubebuilder:validation:Optional
	username?: null | string @go(Username,*string)

	// True if the master's common name
	// value is checked during the SSL handshake.
	// +kubebuilder:validation:Optional
	verifyServerCertificate?: null | bool @go(VerifyServerCertificate,*bool)
}

#RestoreBackupContextInitParameters: {
	// The ID of the backup run to restore from.
	backupRunId?: null | float64 @go(BackupRunID,*float64)

	// The ID of the instance that the backup was taken from. If left empty,
	// this instance's ID will be used.
	instanceId?: null | string @go(InstanceID,*string)

	// The full project ID of the source instance.`
	project?: null | string @go(Project,*string)
}

#RestoreBackupContextObservation: {
	// The ID of the backup run to restore from.
	backupRunId?: null | float64 @go(BackupRunID,*float64)

	// The ID of the instance that the backup was taken from. If left empty,
	// this instance's ID will be used.
	instanceId?: null | string @go(InstanceID,*string)

	// The full project ID of the source instance.`
	project?: null | string @go(Project,*string)
}

#RestoreBackupContextParameters: {
	// The ID of the backup run to restore from.
	// +kubebuilder:validation:Optional
	backupRunId?: null | float64 @go(BackupRunID,*float64)

	// The ID of the instance that the backup was taken from. If left empty,
	// this instance's ID will be used.
	// +kubebuilder:validation:Optional
	instanceId?: null | string @go(InstanceID,*string)

	// The full project ID of the source instance.`
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)
}

#SQLServerAuditConfigInitParameters: {
	// The name of the destination bucket (e.g., gs://mybucket).
	bucket?: null | string @go(Bucket,*string)

	// How long to keep generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	retentionInterval?: null | string @go(RetentionInterval,*string)

	// How often to upload generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	uploadInterval?: null | string @go(UploadInterval,*string)
}

#SQLServerAuditConfigObservation: {
	// The name of the destination bucket (e.g., gs://mybucket).
	bucket?: null | string @go(Bucket,*string)

	// How long to keep generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	retentionInterval?: null | string @go(RetentionInterval,*string)

	// How often to upload generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	uploadInterval?: null | string @go(UploadInterval,*string)
}

#SQLServerAuditConfigParameters: {
	// The name of the destination bucket (e.g., gs://mybucket).
	// +kubebuilder:validation:Optional
	bucket?: null | string @go(Bucket,*string)

	// How long to keep generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	retentionInterval?: null | string @go(RetentionInterval,*string)

	// How often to upload generated audit files. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
	// +kubebuilder:validation:Optional
	uploadInterval?: null | string @go(UploadInterval,*string)
}

#ServerCACertInitParameters: {
}

#ServerCACertObservation: {
	// The CA Certificate used to connect to the SQL Instance via SSL.
	cert?: null | string @go(Cert,*string)

	// The CN valid for the CA Cert.
	commonName?: null | string @go(CommonName,*string)

	// Creation time of the CA Cert.
	createTime?: null | string @go(CreateTime,*string)

	// The RFC 3339
	// formatted date time string indicating when this whitelist expires.
	expirationTime?: null | string @go(ExpirationTime,*string)

	// SHA Fingerprint of the CA Cert.
	sha1Fingerprint?: null | string @go(Sha1Fingerprint,*string)
}

#ServerCACertParameters: {
}

#SettingsInitParameters: {
	// This specifies when the instance should be
	// active. Can be either ALWAYS, NEVER or ON_DEMAND.
	activationPolicy?: null | string @go(ActivationPolicy,*string)
	activeDirectoryConfig?: [...#ActiveDirectoryConfigInitParameters] @go(ActiveDirectoryConfig,[]ActiveDirectoryConfigInitParameters)
	advancedMachineFeatures?: [...#AdvancedMachineFeaturesInitParameters] @go(AdvancedMachineFeatures,[]AdvancedMachineFeaturesInitParameters)

	// The availability type of the Cloud SQL
	// instance, high availability (REGIONAL) or single zone (ZONAL).' For all instances, ensure that
	// settings.backup_configuration.enabled is set to true.
	// For MySQL instances, ensure that settings.backup_configuration.binary_log_enabled is set to true.
	// For Postgres and SQL Server instances, ensure that settings.backup_configuration.point_in_time_recovery_enabled
	// is set to true. Defaults to ZONAL.
	availabilityType?: null | string @go(AvailabilityType,*string)
	backupConfiguration?: [...#BackupConfigurationInitParameters] @go(BackupConfiguration,[]BackupConfigurationInitParameters)

	// The name of server instance collation.
	collation?: null | string @go(Collation,*string)

	// Specifies if connections must use Cloud SQL connectors.
	connectorEnforcement?: null | string @go(ConnectorEnforcement,*string)
	dataCacheConfig?: [...#DataCacheConfigInitParameters] @go(DataCacheConfig,[]DataCacheConfigInitParameters)
	databaseFlags?: [...#DatabaseFlagsInitParameters] @go(DatabaseFlags,[]DatabaseFlagsInitParameters)

	// .
	deletionProtectionEnabled?: null | bool @go(DeletionProtectionEnabled,*bool)
	denyMaintenancePeriod?: [...#DenyMaintenancePeriodInitParameters] @go(DenyMaintenancePeriod,[]DenyMaintenancePeriodInitParameters)

	// Enables auto-resizing of the storage size. Defaults to true.
	diskAutoresize?: null | bool @go(DiskAutoresize,*bool)

	// The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
	diskAutoresizeLimit?: null | float64 @go(DiskAutoresizeLimit,*float64)

	// The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
	diskSize?: null | float64 @go(DiskSize,*float64)

	// The type of data disk: PD_SSD or PD_HDD. Defaults to PD_SSD.
	diskType?: null | string @go(DiskType,*string)

	// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
	edition?: null | string @go(Edition,*string)
	ipConfiguration?: [...#IPConfigurationInitParameters] @go(IPConfiguration,[]IPConfigurationInitParameters)
	insightsConfig?: [...#InsightsConfigInitParameters] @go(InsightsConfig,[]InsightsConfigInitParameters)
	locationPreference?: [...#LocationPreferenceInitParameters] @go(LocationPreference,[]LocationPreferenceInitParameters)
	maintenanceWindow?: [...#MaintenanceWindowInitParameters] @go(MaintenanceWindow,[]MaintenanceWindowInitParameters)
	passwordValidationPolicy?: [...#PasswordValidationPolicyInitParameters] @go(PasswordValidationPolicy,[]PasswordValidationPolicyInitParameters)

	// Pricing plan for this instance, can only be PER_USE.
	pricingPlan?: null | string @go(PricingPlan,*string)
	sqlServerAuditConfig?: [...#SQLServerAuditConfigInitParameters] @go(SQLServerAuditConfig,[]SQLServerAuditConfigInitParameters)

	// The machine type to use. See tiers
	// for more details and supported versions. Postgres supports only shared-core machine types,
	// and custom machine types such as db-custom-2-13312. See the Custom Machine Type Documentation to learn about specifying custom machine types.
	tier?: null | string @go(Tier,*string)

	// The time_zone to be used by the database engine (supported only for SQL Server), in SQL Server timezone format.
	timeZone?: null | string @go(TimeZone,*string)

	// A set of key/value user label pairs to assign to the instance.
	userLabels?: {[string]: null | string} @go(UserLabels,map[string]*string)
}

#SettingsObservation: {
	// This specifies when the instance should be
	// active. Can be either ALWAYS, NEVER or ON_DEMAND.
	activationPolicy?: null | string @go(ActivationPolicy,*string)
	activeDirectoryConfig?: [...#ActiveDirectoryConfigObservation] @go(ActiveDirectoryConfig,[]ActiveDirectoryConfigObservation)
	advancedMachineFeatures?: [...#AdvancedMachineFeaturesObservation] @go(AdvancedMachineFeatures,[]AdvancedMachineFeaturesObservation)

	// The availability type of the Cloud SQL
	// instance, high availability (REGIONAL) or single zone (ZONAL).' For all instances, ensure that
	// settings.backup_configuration.enabled is set to true.
	// For MySQL instances, ensure that settings.backup_configuration.binary_log_enabled is set to true.
	// For Postgres and SQL Server instances, ensure that settings.backup_configuration.point_in_time_recovery_enabled
	// is set to true. Defaults to ZONAL.
	availabilityType?: null | string @go(AvailabilityType,*string)
	backupConfiguration?: [...#BackupConfigurationObservation] @go(BackupConfiguration,[]BackupConfigurationObservation)

	// The name of server instance collation.
	collation?: null | string @go(Collation,*string)

	// Specifies if connections must use Cloud SQL connectors.
	connectorEnforcement?: null | string @go(ConnectorEnforcement,*string)
	dataCacheConfig?: [...#DataCacheConfigObservation] @go(DataCacheConfig,[]DataCacheConfigObservation)
	databaseFlags?: [...#DatabaseFlagsObservation] @go(DatabaseFlags,[]DatabaseFlagsObservation)

	// .
	deletionProtectionEnabled?: null | bool @go(DeletionProtectionEnabled,*bool)
	denyMaintenancePeriod?: [...#DenyMaintenancePeriodObservation] @go(DenyMaintenancePeriod,[]DenyMaintenancePeriodObservation)

	// Enables auto-resizing of the storage size. Defaults to true.
	diskAutoresize?: null | bool @go(DiskAutoresize,*bool)

	// The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
	diskAutoresizeLimit?: null | float64 @go(DiskAutoresizeLimit,*float64)

	// The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
	diskSize?: null | float64 @go(DiskSize,*float64)

	// The type of data disk: PD_SSD or PD_HDD. Defaults to PD_SSD.
	diskType?: null | string @go(DiskType,*string)

	// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
	edition?: null | string @go(Edition,*string)
	ipConfiguration?: [...#IPConfigurationObservation] @go(IPConfiguration,[]IPConfigurationObservation)
	insightsConfig?: [...#InsightsConfigObservation] @go(InsightsConfig,[]InsightsConfigObservation)
	locationPreference?: [...#LocationPreferenceObservation] @go(LocationPreference,[]LocationPreferenceObservation)
	maintenanceWindow?: [...#MaintenanceWindowObservation] @go(MaintenanceWindow,[]MaintenanceWindowObservation)
	passwordValidationPolicy?: [...#PasswordValidationPolicyObservation] @go(PasswordValidationPolicy,[]PasswordValidationPolicyObservation)

	// Pricing plan for this instance, can only be PER_USE.
	pricingPlan?: null | string @go(PricingPlan,*string)
	sqlServerAuditConfig?: [...#SQLServerAuditConfigObservation] @go(SQLServerAuditConfig,[]SQLServerAuditConfigObservation)

	// The machine type to use. See tiers
	// for more details and supported versions. Postgres supports only shared-core machine types,
	// and custom machine types such as db-custom-2-13312. See the Custom Machine Type Documentation to learn about specifying custom machine types.
	tier?: null | string @go(Tier,*string)

	// The time_zone to be used by the database engine (supported only for SQL Server), in SQL Server timezone format.
	timeZone?: null | string @go(TimeZone,*string)

	// A set of key/value user label pairs to assign to the instance.
	userLabels?: {[string]: null | string} @go(UserLabels,map[string]*string)

	// Used to make sure changes to the settings block are
	// atomic.
	version?: null | float64 @go(Version,*float64)
}

#SettingsParameters: {
	// This specifies when the instance should be
	// active. Can be either ALWAYS, NEVER or ON_DEMAND.
	// +kubebuilder:validation:Optional
	activationPolicy?: null | string @go(ActivationPolicy,*string)

	// +kubebuilder:validation:Optional
	activeDirectoryConfig?: [...#ActiveDirectoryConfigParameters] @go(ActiveDirectoryConfig,[]ActiveDirectoryConfigParameters)

	// +kubebuilder:validation:Optional
	advancedMachineFeatures?: [...#AdvancedMachineFeaturesParameters] @go(AdvancedMachineFeatures,[]AdvancedMachineFeaturesParameters)

	// The availability type of the Cloud SQL
	// instance, high availability (REGIONAL) or single zone (ZONAL).' For all instances, ensure that
	// settings.backup_configuration.enabled is set to true.
	// For MySQL instances, ensure that settings.backup_configuration.binary_log_enabled is set to true.
	// For Postgres and SQL Server instances, ensure that settings.backup_configuration.point_in_time_recovery_enabled
	// is set to true. Defaults to ZONAL.
	// +kubebuilder:validation:Optional
	availabilityType?: null | string @go(AvailabilityType,*string)

	// +kubebuilder:validation:Optional
	backupConfiguration?: [...#BackupConfigurationParameters] @go(BackupConfiguration,[]BackupConfigurationParameters)

	// The name of server instance collation.
	// +kubebuilder:validation:Optional
	collation?: null | string @go(Collation,*string)

	// Specifies if connections must use Cloud SQL connectors.
	// +kubebuilder:validation:Optional
	connectorEnforcement?: null | string @go(ConnectorEnforcement,*string)

	// +kubebuilder:validation:Optional
	dataCacheConfig?: [...#DataCacheConfigParameters] @go(DataCacheConfig,[]DataCacheConfigParameters)

	// +kubebuilder:validation:Optional
	databaseFlags?: [...#DatabaseFlagsParameters] @go(DatabaseFlags,[]DatabaseFlagsParameters)

	// .
	// +kubebuilder:validation:Optional
	deletionProtectionEnabled?: null | bool @go(DeletionProtectionEnabled,*bool)

	// +kubebuilder:validation:Optional
	denyMaintenancePeriod?: [...#DenyMaintenancePeriodParameters] @go(DenyMaintenancePeriod,[]DenyMaintenancePeriodParameters)

	// Enables auto-resizing of the storage size. Defaults to true.
	// +kubebuilder:validation:Optional
	diskAutoresize?: null | bool @go(DiskAutoresize,*bool)

	// The maximum size to which storage capacity can be automatically increased. The default value is 0, which specifies that there is no limit.
	// +kubebuilder:validation:Optional
	diskAutoresizeLimit?: null | float64 @go(DiskAutoresizeLimit,*float64)

	// The size of data disk, in GB. Size of a running instance cannot be reduced but can be increased. The minimum value is 10GB.
	// +kubebuilder:validation:Optional
	diskSize?: null | float64 @go(DiskSize,*float64)

	// The type of data disk: PD_SSD or PD_HDD. Defaults to PD_SSD.
	// +kubebuilder:validation:Optional
	diskType?: null | string @go(DiskType,*string)

	// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
	// +kubebuilder:validation:Optional
	edition?: null | string @go(Edition,*string)

	// +kubebuilder:validation:Optional
	ipConfiguration?: [...#IPConfigurationParameters] @go(IPConfiguration,[]IPConfigurationParameters)

	// +kubebuilder:validation:Optional
	insightsConfig?: [...#InsightsConfigParameters] @go(InsightsConfig,[]InsightsConfigParameters)

	// +kubebuilder:validation:Optional
	locationPreference?: [...#LocationPreferenceParameters] @go(LocationPreference,[]LocationPreferenceParameters)

	// +kubebuilder:validation:Optional
	maintenanceWindow?: [...#MaintenanceWindowParameters] @go(MaintenanceWindow,[]MaintenanceWindowParameters)

	// +kubebuilder:validation:Optional
	passwordValidationPolicy?: [...#PasswordValidationPolicyParameters] @go(PasswordValidationPolicy,[]PasswordValidationPolicyParameters)

	// Pricing plan for this instance, can only be PER_USE.
	// +kubebuilder:validation:Optional
	pricingPlan?: null | string @go(PricingPlan,*string)

	// +kubebuilder:validation:Optional
	sqlServerAuditConfig?: [...#SQLServerAuditConfigParameters] @go(SQLServerAuditConfig,[]SQLServerAuditConfigParameters)

	// The machine type to use. See tiers
	// for more details and supported versions. Postgres supports only shared-core machine types,
	// and custom machine types such as db-custom-2-13312. See the Custom Machine Type Documentation to learn about specifying custom machine types.
	// +kubebuilder:validation:Optional
	tier?: null | string @go(Tier,*string)

	// The time_zone to be used by the database engine (supported only for SQL Server), in SQL Server timezone format.
	// +kubebuilder:validation:Optional
	timeZone?: null | string @go(TimeZone,*string)

	// A set of key/value user label pairs to assign to the instance.
	// +kubebuilder:validation:Optional
	userLabels?: {[string]: null | string} @go(UserLabels,map[string]*string)
}

// DatabaseInstanceSpec defines the desired state of DatabaseInstance
#DatabaseInstanceSpec: {
	v1.#ResourceSpec
	forProvider: #DatabaseInstanceParameters @go(ForProvider)

	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #DatabaseInstanceInitParameters @go(InitProvider)
}

// DatabaseInstanceStatus defines the observed state of DatabaseInstance.
#DatabaseInstanceStatus: {
	v1.#ResourceStatus
	atProvider?: #DatabaseInstanceObservation @go(AtProvider)
}

// DatabaseInstance is the Schema for the DatabaseInstances API. Creates a new SQL database instance in Google Cloud SQL.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#DatabaseInstance: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.databaseVersion) || (has(self.initProvider) && has(self.initProvider.databaseVersion))",message="spec.forProvider.databaseVersion is a required parameter"
	spec:    #DatabaseInstanceSpec   @go(Spec)
	status?: #DatabaseInstanceStatus @go(Status)
}

// DatabaseInstanceList contains a list of DatabaseInstances
#DatabaseInstanceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#DatabaseInstance] @go(Items,[]DatabaseInstance)
}
