// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/compute/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#ConsistentHashHTTPCookieInitParameters: {
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	name?: null | string @go(Name,*string)

	// Path to set for the cookie.
	path?: null | string @go(Path,*string)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	ttl?: [...#HTTPCookieTTLInitParameters] @go(TTL,[]HTTPCookieTTLInitParameters)
}

#ConsistentHashHTTPCookieObservation: {
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	name?: null | string @go(Name,*string)

	// Path to set for the cookie.
	path?: null | string @go(Path,*string)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	ttl?: [...#HTTPCookieTTLObservation] @go(TTL,[]HTTPCookieTTLObservation)
}

#ConsistentHashHTTPCookieParameters: {
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Path to set for the cookie.
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	// +kubebuilder:validation:Optional
	ttl?: [...#HTTPCookieTTLParameters] @go(TTL,[]HTTPCookieTTLParameters)
}

#FailoverPolicyInitParameters: {
	// On failover or failback, this field indicates whether connection drain
	// will be honored. Setting this to true has the following effect: connections
	// to the old active pool are not drained. Connections to the new active pool
	// use the timeout of 10 min (currently fixed). Setting to false has the
	// following effect: both old and new connections will have a drain timeout
	// of 10 min.
	// This can be set to true only if the protocol is TCP.
	// The default is false.
	disableConnectionDrainOnFailover?: null | bool @go(DisableConnectionDrainOnFailover,*bool)

	// This option is used only when no healthy VMs are detected in the primary
	// and backup instance groups. When set to true, traffic is dropped. When
	// set to false, new connections are sent across all VMs in the primary group.
	// The default is false.
	dropTrafficIfUnhealthy?: null | bool @go(DropTrafficIfUnhealthy,*bool)

	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic arriving
	// at the load-balanced IP will be directed to the failover backend.
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the primary
	// backend in the "force" mode, where traffic will be spread to the healthy
	// VMs with the best effort, or to all VMs when no VM is healthy.
	// This field is only used with l4 load balancing.
	failoverRatio?: null | float64 @go(FailoverRatio,*float64)
}

#FailoverPolicyObservation: {
	// On failover or failback, this field indicates whether connection drain
	// will be honored. Setting this to true has the following effect: connections
	// to the old active pool are not drained. Connections to the new active pool
	// use the timeout of 10 min (currently fixed). Setting to false has the
	// following effect: both old and new connections will have a drain timeout
	// of 10 min.
	// This can be set to true only if the protocol is TCP.
	// The default is false.
	disableConnectionDrainOnFailover?: null | bool @go(DisableConnectionDrainOnFailover,*bool)

	// This option is used only when no healthy VMs are detected in the primary
	// and backup instance groups. When set to true, traffic is dropped. When
	// set to false, new connections are sent across all VMs in the primary group.
	// The default is false.
	dropTrafficIfUnhealthy?: null | bool @go(DropTrafficIfUnhealthy,*bool)

	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic arriving
	// at the load-balanced IP will be directed to the failover backend.
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the primary
	// backend in the "force" mode, where traffic will be spread to the healthy
	// VMs with the best effort, or to all VMs when no VM is healthy.
	// This field is only used with l4 load balancing.
	failoverRatio?: null | float64 @go(FailoverRatio,*float64)
}

#FailoverPolicyParameters: {
	// On failover or failback, this field indicates whether connection drain
	// will be honored. Setting this to true has the following effect: connections
	// to the old active pool are not drained. Connections to the new active pool
	// use the timeout of 10 min (currently fixed). Setting to false has the
	// following effect: both old and new connections will have a drain timeout
	// of 10 min.
	// This can be set to true only if the protocol is TCP.
	// The default is false.
	// +kubebuilder:validation:Optional
	disableConnectionDrainOnFailover?: null | bool @go(DisableConnectionDrainOnFailover,*bool)

	// This option is used only when no healthy VMs are detected in the primary
	// and backup instance groups. When set to true, traffic is dropped. When
	// set to false, new connections are sent across all VMs in the primary group.
	// The default is false.
	// +kubebuilder:validation:Optional
	dropTrafficIfUnhealthy?: null | bool @go(DropTrafficIfUnhealthy,*bool)

	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic arriving
	// at the load-balanced IP will be directed to the failover backend.
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the primary
	// backend in the "force" mode, where traffic will be spread to the healthy
	// VMs with the best effort, or to all VMs when no VM is healthy.
	// This field is only used with l4 load balancing.
	// +kubebuilder:validation:Optional
	failoverRatio?: null | float64 @go(FailoverRatio,*float64)
}

#HTTPCookieTTLInitParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#HTTPCookieTTLObservation: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#HTTPCookieTTLParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	seconds?: null | float64 @go(Seconds,*float64)
}

#OutlierDetectionBaseEjectionTimeInitParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#OutlierDetectionBaseEjectionTimeObservation: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#OutlierDetectionBaseEjectionTimeParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	seconds?: null | float64 @go(Seconds,*float64)
}

#OutlierDetectionIntervalInitParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#OutlierDetectionIntervalObservation: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#OutlierDetectionIntervalParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	seconds?: null | float64 @go(Seconds,*float64)
}

#RegionBackendServiceBackendInitParameters: {
	// Specifies the balancing mode for this backend.
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is CONNECTION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	balancingMode?: null | string @go(BalancingMode,*string)

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// ~>NOTE: This field cannot be set for
	// INTERNAL region backend services (default loadBalancingScheme),
	// but is required for non-INTERNAL backend service. The total
	// capacity_scaler for all backends must be non-zero.
	// A setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	capacityScaler?: null | float64 @go(CapacityScaler,*float64)

	// An optional description of this resource.
	// Provide this property when you create the resource.
	description?: null | string @go(Description,*string)

	// This field designates whether this is a failover backend. More
	// than one failover backend can be configured for a given RegionBackendService.
	failover?: null | bool @go(Failover,*bool)

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// Cannot be set for INTERNAL backend services.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. Cannot be set
	// for INTERNAL backend services.
	// This is used to calculate the capacity of the group. Can be
	// used in either CONNECTION or UTILIZATION balancing modes. For
	// CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	maxConnectionsPerEndpoint?: null | float64 @go(MaxConnectionsPerEndpoint,*float64)

	// The max number of simultaneous connections that a single
	// backend instance can handle. Cannot be set for INTERNAL backend
	// services.
	// This is used to calculate the capacity of the group.
	// Can be used in either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	maxConnectionsPerInstance?: null | float64 @go(MaxConnectionsPerInstance,*float64)

	// The max requests per second (RPS) of the group. Cannot be set
	// for INTERNAL backend services.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. Either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	maxRate?: null | float64 @go(MaxRate,*float64)

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set. Cannot be set
	// for INTERNAL backend services.
	maxRatePerEndpoint?: null | float64 @go(MaxRatePerEndpoint,*float64)

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set. Cannot be set
	// for INTERNAL backend services.
	maxRatePerInstance?: null | float64 @go(MaxRatePerInstance,*float64)

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// Cannot be set for INTERNAL backend services.
	maxUtilization?: null | float64 @go(MaxUtilization,*float64)
}

#RegionBackendServiceBackendObservation: {
	// Specifies the balancing mode for this backend.
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is CONNECTION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	balancingMode?: null | string @go(BalancingMode,*string)

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// ~>NOTE: This field cannot be set for
	// INTERNAL region backend services (default loadBalancingScheme),
	// but is required for non-INTERNAL backend service. The total
	// capacity_scaler for all backends must be non-zero.
	// A setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	capacityScaler?: null | float64 @go(CapacityScaler,*float64)

	// An optional description of this resource.
	// Provide this property when you create the resource.
	description?: null | string @go(Description,*string)

	// This field designates whether this is a failover backend. More
	// than one failover backend can be configured for a given RegionBackendService.
	failover?: null | bool @go(Failover,*bool)

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// When the load_balancing_scheme is INTERNAL, only instance groups
	// are supported.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	group?: null | string @go(Group,*string)

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// Cannot be set for INTERNAL backend services.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. Cannot be set
	// for INTERNAL backend services.
	// This is used to calculate the capacity of the group. Can be
	// used in either CONNECTION or UTILIZATION balancing modes. For
	// CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	maxConnectionsPerEndpoint?: null | float64 @go(MaxConnectionsPerEndpoint,*float64)

	// The max number of simultaneous connections that a single
	// backend instance can handle. Cannot be set for INTERNAL backend
	// services.
	// This is used to calculate the capacity of the group.
	// Can be used in either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	maxConnectionsPerInstance?: null | float64 @go(MaxConnectionsPerInstance,*float64)

	// The max requests per second (RPS) of the group. Cannot be set
	// for INTERNAL backend services.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. Either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	maxRate?: null | float64 @go(MaxRate,*float64)

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set. Cannot be set
	// for INTERNAL backend services.
	maxRatePerEndpoint?: null | float64 @go(MaxRatePerEndpoint,*float64)

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set. Cannot be set
	// for INTERNAL backend services.
	maxRatePerInstance?: null | float64 @go(MaxRatePerInstance,*float64)

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// Cannot be set for INTERNAL backend services.
	maxUtilization?: null | float64 @go(MaxUtilization,*float64)
}

#RegionBackendServiceBackendParameters: {
	// Specifies the balancing mode for this backend.
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is CONNECTION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	// +kubebuilder:validation:Optional
	balancingMode?: null | string @go(BalancingMode,*string)

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// ~>NOTE: This field cannot be set for
	// INTERNAL region backend services (default loadBalancingScheme),
	// but is required for non-INTERNAL backend service. The total
	// capacity_scaler for all backends must be non-zero.
	// A setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	// +kubebuilder:validation:Optional
	capacityScaler?: null | float64 @go(CapacityScaler,*float64)

	// An optional description of this resource.
	// Provide this property when you create the resource.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// This field designates whether this is a failover backend. More
	// than one failover backend can be configured for a given RegionBackendService.
	// +kubebuilder:validation:Optional
	failover?: null | bool @go(Failover,*bool)

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// When the load_balancing_scheme is INTERNAL, only instance groups
	// are supported.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	// +crossplane:generate:reference:type=RegionInstanceGroupManager
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/compute.InstanceGroupExtractor()
	// +kubebuilder:validation:Optional
	group?: null | string @go(Group,*string)

	// Reference to a RegionInstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	groupRef?: null | v1.#Reference @go(GroupRef,*v1.Reference)

	// Selector for a RegionInstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	groupSelector?: null | v1.#Selector @go(GroupSelector,*v1.Selector)

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// Cannot be set for INTERNAL backend services.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	// +kubebuilder:validation:Optional
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. Cannot be set
	// for INTERNAL backend services.
	// This is used to calculate the capacity of the group. Can be
	// used in either CONNECTION or UTILIZATION balancing modes. For
	// CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	// +kubebuilder:validation:Optional
	maxConnectionsPerEndpoint?: null | float64 @go(MaxConnectionsPerEndpoint,*float64)

	// The max number of simultaneous connections that a single
	// backend instance can handle. Cannot be set for INTERNAL backend
	// services.
	// This is used to calculate the capacity of the group.
	// Can be used in either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	// +kubebuilder:validation:Optional
	maxConnectionsPerInstance?: null | float64 @go(MaxConnectionsPerInstance,*float64)

	// The max requests per second (RPS) of the group. Cannot be set
	// for INTERNAL backend services.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. Either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	// +kubebuilder:validation:Optional
	maxRate?: null | float64 @go(MaxRate,*float64)

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set. Cannot be set
	// for INTERNAL backend services.
	// +kubebuilder:validation:Optional
	maxRatePerEndpoint?: null | float64 @go(MaxRatePerEndpoint,*float64)

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set. Cannot be set
	// for INTERNAL backend services.
	// +kubebuilder:validation:Optional
	maxRatePerInstance?: null | float64 @go(MaxRatePerInstance,*float64)

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// Cannot be set for INTERNAL backend services.
	// +kubebuilder:validation:Optional
	maxUtilization?: null | float64 @go(MaxUtilization,*float64)
}

#RegionBackendServiceCdnPolicyCacheKeyPolicyInitParameters: {
	// If true requests to different hosts will be cached separately.
	includeHost?: null | bool @go(IncludeHost,*bool)

	// Names of cookies to include in cache keys.
	includeNamedCookies?: [...null | string] @go(IncludeNamedCookies,[]*string)

	// If true, http and https requests will be cached separately.
	includeProtocol?: null | bool @go(IncludeProtocol,*bool)

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	includeQueryString?: null | bool @go(IncludeQueryString,*bool)

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringBlacklist?: [...null | string] @go(QueryStringBlacklist,[]*string)

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringWhitelist?: [...null | string] @go(QueryStringWhitelist,[]*string)
}

#RegionBackendServiceCdnPolicyCacheKeyPolicyObservation: {
	// If true requests to different hosts will be cached separately.
	includeHost?: null | bool @go(IncludeHost,*bool)

	// Names of cookies to include in cache keys.
	includeNamedCookies?: [...null | string] @go(IncludeNamedCookies,[]*string)

	// If true, http and https requests will be cached separately.
	includeProtocol?: null | bool @go(IncludeProtocol,*bool)

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	includeQueryString?: null | bool @go(IncludeQueryString,*bool)

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringBlacklist?: [...null | string] @go(QueryStringBlacklist,[]*string)

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringWhitelist?: [...null | string] @go(QueryStringWhitelist,[]*string)
}

#RegionBackendServiceCdnPolicyCacheKeyPolicyParameters: {
	// If true requests to different hosts will be cached separately.
	// +kubebuilder:validation:Optional
	includeHost?: null | bool @go(IncludeHost,*bool)

	// Names of cookies to include in cache keys.
	// +kubebuilder:validation:Optional
	includeNamedCookies?: [...null | string] @go(IncludeNamedCookies,[]*string)

	// If true, http and https requests will be cached separately.
	// +kubebuilder:validation:Optional
	includeProtocol?: null | bool @go(IncludeProtocol,*bool)

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	// +kubebuilder:validation:Optional
	includeQueryString?: null | bool @go(IncludeQueryString,*bool)

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	queryStringBlacklist?: [...null | string] @go(QueryStringBlacklist,[]*string)

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	queryStringWhitelist?: [...null | string] @go(QueryStringWhitelist,[]*string)
}

#RegionBackendServiceCdnPolicyInitParameters: {
	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	cacheKeyPolicy?: [...#RegionBackendServiceCdnPolicyCacheKeyPolicyInitParameters] @go(CacheKeyPolicy,[]RegionBackendServiceCdnPolicyCacheKeyPolicyInitParameters)

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	cacheMode?: null | string @go(CacheMode,*string)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	clientTtl?: null | float64 @go(ClientTTL,*float64)

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	defaultTtl?: null | float64 @go(DefaultTTL,*float64)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	maxTtl?: null | float64 @go(MaxTTL,*float64)

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	negativeCaching?: null | bool @go(NegativeCaching,*bool)

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	negativeCachingPolicy?: [...#RegionBackendServiceCdnPolicyNegativeCachingPolicyInitParameters] @go(NegativeCachingPolicy,[]RegionBackendServiceCdnPolicyNegativeCachingPolicyInitParameters)

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	serveWhileStale?: null | float64 @go(ServeWhileStale,*float64)

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	signedUrlCacheMaxAgeSec?: null | float64 @go(SignedURLCacheMaxAgeSec,*float64)
}

#RegionBackendServiceCdnPolicyNegativeCachingPolicyInitParameters: {
	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	code?: null | float64 @go(Code,*float64)
}

#RegionBackendServiceCdnPolicyNegativeCachingPolicyObservation: {
	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	code?: null | float64 @go(Code,*float64)
}

#RegionBackendServiceCdnPolicyNegativeCachingPolicyParameters: {
	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	// +kubebuilder:validation:Optional
	code?: null | float64 @go(Code,*float64)
}

#RegionBackendServiceCdnPolicyObservation: {
	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	cacheKeyPolicy?: [...#RegionBackendServiceCdnPolicyCacheKeyPolicyObservation] @go(CacheKeyPolicy,[]RegionBackendServiceCdnPolicyCacheKeyPolicyObservation)

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	cacheMode?: null | string @go(CacheMode,*string)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	clientTtl?: null | float64 @go(ClientTTL,*float64)

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	defaultTtl?: null | float64 @go(DefaultTTL,*float64)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	maxTtl?: null | float64 @go(MaxTTL,*float64)

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	negativeCaching?: null | bool @go(NegativeCaching,*bool)

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	negativeCachingPolicy?: [...#RegionBackendServiceCdnPolicyNegativeCachingPolicyObservation] @go(NegativeCachingPolicy,[]RegionBackendServiceCdnPolicyNegativeCachingPolicyObservation)

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	serveWhileStale?: null | float64 @go(ServeWhileStale,*float64)

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	signedUrlCacheMaxAgeSec?: null | float64 @go(SignedURLCacheMaxAgeSec,*float64)
}

#RegionBackendServiceCdnPolicyParameters: {
	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cacheKeyPolicy?: [...#RegionBackendServiceCdnPolicyCacheKeyPolicyParameters] @go(CacheKeyPolicy,[]RegionBackendServiceCdnPolicyCacheKeyPolicyParameters)

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	// +kubebuilder:validation:Optional
	cacheMode?: null | string @go(CacheMode,*string)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	clientTtl?: null | float64 @go(ClientTTL,*float64)

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	// +kubebuilder:validation:Optional
	defaultTtl?: null | float64 @go(DefaultTTL,*float64)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	maxTtl?: null | float64 @go(MaxTTL,*float64)

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	// +kubebuilder:validation:Optional
	negativeCaching?: null | bool @go(NegativeCaching,*bool)

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	negativeCachingPolicy?: [...#RegionBackendServiceCdnPolicyNegativeCachingPolicyParameters] @go(NegativeCachingPolicy,[]RegionBackendServiceCdnPolicyNegativeCachingPolicyParameters)

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	// +kubebuilder:validation:Optional
	serveWhileStale?: null | float64 @go(ServeWhileStale,*float64)

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	// +kubebuilder:validation:Optional
	signedUrlCacheMaxAgeSec?: null | float64 @go(SignedURLCacheMaxAgeSec,*float64)
}

#RegionBackendServiceCircuitBreakersInitParameters: {
	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	maxRequests?: null | float64 @go(MaxRequests,*float64)

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	maxRequestsPerConnection?: null | float64 @go(MaxRequestsPerConnection,*float64)

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	maxRetries?: null | float64 @go(MaxRetries,*float64)
}

#RegionBackendServiceCircuitBreakersObservation: {
	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	maxRequests?: null | float64 @go(MaxRequests,*float64)

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	maxRequestsPerConnection?: null | float64 @go(MaxRequestsPerConnection,*float64)

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	maxRetries?: null | float64 @go(MaxRetries,*float64)
}

#RegionBackendServiceCircuitBreakersParameters: {
	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	maxRequests?: null | float64 @go(MaxRequests,*float64)

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	// +kubebuilder:validation:Optional
	maxRequestsPerConnection?: null | float64 @go(MaxRequestsPerConnection,*float64)

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	// +kubebuilder:validation:Optional
	maxRetries?: null | float64 @go(MaxRetries,*float64)
}

#RegionBackendServiceConsistentHashInitParameters: {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	httpCookie?: [...#ConsistentHashHTTPCookieInitParameters] @go(HTTPCookie,[]ConsistentHashHTTPCookieInitParameters)

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	httpHeaderName?: null | string @go(HTTPHeaderName,*string)

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	minimumRingSize?: null | float64 @go(MinimumRingSize,*float64)
}

#RegionBackendServiceConsistentHashObservation: {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	httpCookie?: [...#ConsistentHashHTTPCookieObservation] @go(HTTPCookie,[]ConsistentHashHTTPCookieObservation)

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	httpHeaderName?: null | string @go(HTTPHeaderName,*string)

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	minimumRingSize?: null | float64 @go(MinimumRingSize,*float64)
}

#RegionBackendServiceConsistentHashParameters: {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	httpCookie?: [...#ConsistentHashHTTPCookieParameters] @go(HTTPCookie,[]ConsistentHashHTTPCookieParameters)

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	// +kubebuilder:validation:Optional
	httpHeaderName?: null | string @go(HTTPHeaderName,*string)

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	minimumRingSize?: null | float64 @go(MinimumRingSize,*float64)
}

#RegionBackendServiceIapInitParameters: {
	// OAuth2 Client ID for IAP
	oauth2ClientId?: null | string @go(Oauth2ClientID,*string)
}

#RegionBackendServiceIapObservation: {
	// OAuth2 Client ID for IAP
	oauth2ClientId?: null | string @go(Oauth2ClientID,*string)
}

#RegionBackendServiceIapParameters: {
	// OAuth2 Client ID for IAP
	// +kubebuilder:validation:Optional
	oauth2ClientId?: null | string @go(Oauth2ClientID,*string)

	// OAuth2 Client Secret for IAP
	// Note: This property is sensitive and will not be displayed in the plan.
	// +kubebuilder:validation:Required
	oauth2ClientSecretSecretRef: v1.#SecretKeySelector @go(Oauth2ClientSecretSecretRef)
}

#RegionBackendServiceInitParameters: {
	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	affinityCookieTtlSec?: null | float64 @go(AffinityCookieTTLSec,*float64)

	// The set of backends that serve this RegionBackendService.
	// Structure is documented below.
	backend?: [...#RegionBackendServiceBackendInitParameters] @go(Backend,[]RegionBackendServiceBackendInitParameters)

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	cdnPolicy?: [...#RegionBackendServiceCdnPolicyInitParameters] @go(CdnPolicy,[]RegionBackendServiceCdnPolicyInitParameters)

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_MANAGED
	// and the protocol is set to HTTP, HTTPS, or HTTP2.
	// Structure is documented below.
	circuitBreakers?: [...#RegionBackendServiceCircuitBreakersInitParameters] @go(CircuitBreakers,[]RegionBackendServiceCircuitBreakersInitParameters)

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	connectionDrainingTimeoutSec?: null | float64 @go(ConnectionDrainingTimeoutSec,*float64)

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing.
	// This field only applies when all of the following are true -
	consistentHash?: [...#RegionBackendServiceConsistentHashInitParameters] @go(ConsistentHash,[]RegionBackendServiceConsistentHashInitParameters)

	// An optional description of this resource.
	description?: null | string @go(Description,*string)

	// If true, enable Cloud CDN for this RegionBackendService.
	enableCdn?: null | bool @go(EnableCdn,*bool)

	// Policy for failovers.
	// Structure is documented below.
	failoverPolicy?: [...#FailoverPolicyInitParameters] @go(FailoverPolicy,[]FailoverPolicyInitParameters)

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	iap?: [...#RegionBackendServiceIapInitParameters] @go(Iap,[]RegionBackendServiceIapInitParameters)

	// is set to INTERNAL_MANAGED
	loadBalancingScheme?: null | string @go(LoadBalancingScheme,*string)

	// is set to MAGLEV or RING_HASH
	// Structure is documented below.
	localityLbPolicy?: null | string @go(LocalityLBPolicy,*string)

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	logConfig?: [...#RegionBackendServiceLogConfigInitParameters] @go(LogConfig,[]RegionBackendServiceLogConfigInitParameters)

	// The URL of the network to which this backend service belongs.
	// This field can only be specified when the load balancing scheme is set to INTERNAL.
	network?: null | string @go(Network,*string)

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_MANAGED and the protocol is set to HTTP, HTTPS, or HTTP2.
	// Structure is documented below.
	outlierDetection?: [...#RegionBackendServiceOutlierDetectionInitParameters] @go(OutlierDetection,[]RegionBackendServiceOutlierDetectionInitParameters)

	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED
	// and the backends are instance groups. The named port must be defined on each
	// backend instance group. This parameter has no meaning if the backends are NEGs. API sets a
	// default of "http" if not given.
	// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
	portName?: null | string @go(PortName,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// is set to HTTP, HTTPS, or HTTP2
	protocol?: null | string @go(Protocol,*string)

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE, CLIENT_IP_NO_DESTINATION.
	sessionAffinity?: null | string @go(SessionAffinity,*string)

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	timeoutSec?: null | float64 @go(TimeoutSec,*float64)
}

#RegionBackendServiceLogConfigInitParameters: {
	// Whether to enable logging for the load balancer traffic served by this backend service.
	enable?: null | bool @go(Enable,*bool)

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	sampleRate?: null | float64 @go(SampleRate,*float64)
}

#RegionBackendServiceLogConfigObservation: {
	// Whether to enable logging for the load balancer traffic served by this backend service.
	enable?: null | bool @go(Enable,*bool)

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	sampleRate?: null | float64 @go(SampleRate,*float64)
}

#RegionBackendServiceLogConfigParameters: {
	// Whether to enable logging for the load balancer traffic served by this backend service.
	// +kubebuilder:validation:Optional
	enable?: null | bool @go(Enable,*bool)

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	// +kubebuilder:validation:Optional
	sampleRate?: null | float64 @go(SampleRate,*float64)
}

#RegionBackendServiceObservation: {
	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	affinityCookieTtlSec?: null | float64 @go(AffinityCookieTTLSec,*float64)

	// The set of backends that serve this RegionBackendService.
	// Structure is documented below.
	backend?: [...#RegionBackendServiceBackendObservation] @go(Backend,[]RegionBackendServiceBackendObservation)

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	cdnPolicy?: [...#RegionBackendServiceCdnPolicyObservation] @go(CdnPolicy,[]RegionBackendServiceCdnPolicyObservation)

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_MANAGED
	// and the protocol is set to HTTP, HTTPS, or HTTP2.
	// Structure is documented below.
	circuitBreakers?: [...#RegionBackendServiceCircuitBreakersObservation] @go(CircuitBreakers,[]RegionBackendServiceCircuitBreakersObservation)

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	connectionDrainingTimeoutSec?: null | float64 @go(ConnectionDrainingTimeoutSec,*float64)

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing.
	// This field only applies when all of the following are true -
	consistentHash?: [...#RegionBackendServiceConsistentHashObservation] @go(ConsistentHash,[]RegionBackendServiceConsistentHashObservation)

	// Creation timestamp in RFC3339 text format.
	creationTimestamp?: null | string @go(CreationTimestamp,*string)

	// An optional description of this resource.
	description?: null | string @go(Description,*string)

	// If true, enable Cloud CDN for this RegionBackendService.
	enableCdn?: null | bool @go(EnableCdn,*bool)

	// Policy for failovers.
	// Structure is documented below.
	failoverPolicy?: [...#FailoverPolicyObservation] @go(FailoverPolicy,[]FailoverPolicyObservation)

	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking.
	fingerprint?: null | string @go(Fingerprint,*string)

	// The set of URLs to HealthCheck resources for health checking
	// this RegionBackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	healthChecks?: [...null | string] @go(HealthChecks,[]*string)

	// an identifier for the resource with format projects/{{project}}/regions/{{region}}/backendServices/{{name}}
	id?: null | string @go(ID,*string)

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	iap?: [...#RegionBackendServiceIapObservation] @go(Iap,[]RegionBackendServiceIapObservation)

	// is set to INTERNAL_MANAGED
	loadBalancingScheme?: null | string @go(LoadBalancingScheme,*string)

	// is set to MAGLEV or RING_HASH
	// Structure is documented below.
	localityLbPolicy?: null | string @go(LocalityLBPolicy,*string)

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	logConfig?: [...#RegionBackendServiceLogConfigObservation] @go(LogConfig,[]RegionBackendServiceLogConfigObservation)

	// The URL of the network to which this backend service belongs.
	// This field can only be specified when the load balancing scheme is set to INTERNAL.
	network?: null | string @go(Network,*string)

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_MANAGED and the protocol is set to HTTP, HTTPS, or HTTP2.
	// Structure is documented below.
	outlierDetection?: [...#RegionBackendServiceOutlierDetectionObservation] @go(OutlierDetection,[]RegionBackendServiceOutlierDetectionObservation)

	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED
	// and the backends are instance groups. The named port must be defined on each
	// backend instance group. This parameter has no meaning if the backends are NEGs. API sets a
	// default of "http" if not given.
	// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
	portName?: null | string @go(PortName,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// is set to HTTP, HTTPS, or HTTP2
	protocol?: null | string @go(Protocol,*string)

	// The Region in which the created backend service should reside.
	// If it is not provided, the provider region is used.
	region?: null | string @go(Region,*string)

	// The URI of the created resource.
	selfLink?: null | string @go(SelfLink,*string)

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE, CLIENT_IP_NO_DESTINATION.
	sessionAffinity?: null | string @go(SessionAffinity,*string)

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	timeoutSec?: null | float64 @go(TimeoutSec,*float64)
}

#RegionBackendServiceOutlierDetectionInitParameters: {
	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	baseEjectionTime?: [...#OutlierDetectionBaseEjectionTimeInitParameters] @go(BaseEjectionTime,[]OutlierDetectionBaseEjectionTimeInitParameters)

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	consecutiveErrors?: null | float64 @go(ConsecutiveErrors,*float64)

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	consecutiveGatewayFailure?: null | float64 @go(ConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	enforcingConsecutiveErrors?: null | float64 @go(EnforcingConsecutiveErrors,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	enforcingConsecutiveGatewayFailure?: null | float64 @go(EnforcingConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	enforcingSuccessRate?: null | float64 @go(EnforcingSuccessRate,*float64)

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	interval?: [...#OutlierDetectionIntervalInitParameters] @go(Interval,[]OutlierDetectionIntervalInitParameters)

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	successRateMinimumHosts?: null | float64 @go(SuccessRateMinimumHosts,*float64)

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	successRateRequestVolume?: null | float64 @go(SuccessRateRequestVolume,*float64)

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	successRateStdevFactor?: null | float64 @go(SuccessRateStdevFactor,*float64)
}

#RegionBackendServiceOutlierDetectionObservation: {
	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	baseEjectionTime?: [...#OutlierDetectionBaseEjectionTimeObservation] @go(BaseEjectionTime,[]OutlierDetectionBaseEjectionTimeObservation)

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	consecutiveErrors?: null | float64 @go(ConsecutiveErrors,*float64)

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	consecutiveGatewayFailure?: null | float64 @go(ConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	enforcingConsecutiveErrors?: null | float64 @go(EnforcingConsecutiveErrors,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	enforcingConsecutiveGatewayFailure?: null | float64 @go(EnforcingConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	enforcingSuccessRate?: null | float64 @go(EnforcingSuccessRate,*float64)

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	interval?: [...#OutlierDetectionIntervalObservation] @go(Interval,[]OutlierDetectionIntervalObservation)

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	successRateMinimumHosts?: null | float64 @go(SuccessRateMinimumHosts,*float64)

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	successRateRequestVolume?: null | float64 @go(SuccessRateRequestVolume,*float64)

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	successRateStdevFactor?: null | float64 @go(SuccessRateStdevFactor,*float64)
}

#RegionBackendServiceOutlierDetectionParameters: {
	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	baseEjectionTime?: [...#OutlierDetectionBaseEjectionTimeParameters] @go(BaseEjectionTime,[]OutlierDetectionBaseEjectionTimeParameters)

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	// +kubebuilder:validation:Optional
	consecutiveErrors?: null | float64 @go(ConsecutiveErrors,*float64)

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	// +kubebuilder:validation:Optional
	consecutiveGatewayFailure?: null | float64 @go(ConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	enforcingConsecutiveErrors?: null | float64 @go(EnforcingConsecutiveErrors,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	// +kubebuilder:validation:Optional
	enforcingConsecutiveGatewayFailure?: null | float64 @go(EnforcingConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	enforcingSuccessRate?: null | float64 @go(EnforcingSuccessRate,*float64)

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	interval?: [...#OutlierDetectionIntervalParameters] @go(Interval,[]OutlierDetectionIntervalParameters)

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	// +kubebuilder:validation:Optional
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	// +kubebuilder:validation:Optional
	successRateMinimumHosts?: null | float64 @go(SuccessRateMinimumHosts,*float64)

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	// +kubebuilder:validation:Optional
	successRateRequestVolume?: null | float64 @go(SuccessRateRequestVolume,*float64)

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	// +kubebuilder:validation:Optional
	successRateStdevFactor?: null | float64 @go(SuccessRateStdevFactor,*float64)
}

#RegionBackendServiceParameters: {
	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	// +kubebuilder:validation:Optional
	affinityCookieTtlSec?: null | float64 @go(AffinityCookieTTLSec,*float64)

	// The set of backends that serve this RegionBackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	backend?: [...#RegionBackendServiceBackendParameters] @go(Backend,[]RegionBackendServiceBackendParameters)

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cdnPolicy?: [...#RegionBackendServiceCdnPolicyParameters] @go(CdnPolicy,[]RegionBackendServiceCdnPolicyParameters)

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_MANAGED
	// and the protocol is set to HTTP, HTTPS, or HTTP2.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	circuitBreakers?: [...#RegionBackendServiceCircuitBreakersParameters] @go(CircuitBreakers,[]RegionBackendServiceCircuitBreakersParameters)

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	// +kubebuilder:validation:Optional
	connectionDrainingTimeoutSec?: null | float64 @go(ConnectionDrainingTimeoutSec,*float64)

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing.
	// This field only applies when all of the following are true -
	// +kubebuilder:validation:Optional
	consistentHash?: [...#RegionBackendServiceConsistentHashParameters] @go(ConsistentHash,[]RegionBackendServiceConsistentHashParameters)

	// An optional description of this resource.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// If true, enable Cloud CDN for this RegionBackendService.
	// +kubebuilder:validation:Optional
	enableCdn?: null | bool @go(EnableCdn,*bool)

	// Policy for failovers.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	failoverPolicy?: [...#FailoverPolicyParameters] @go(FailoverPolicy,[]FailoverPolicyParameters)

	// The set of URLs to HealthCheck resources for health checking
	// this RegionBackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// +crossplane:generate:reference:type=RegionHealthCheck
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/common.SelfLinkExtractor()
	// +kubebuilder:validation:Optional
	healthChecks?: [...null | string] @go(HealthChecks,[]*string)

	// References to RegionHealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	healthChecksRefs?: [...v1.#Reference] @go(HealthChecksRefs,[]v1.Reference)

	// Selector for a list of RegionHealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	healthChecksSelector?: null | v1.#Selector @go(HealthChecksSelector,*v1.Selector)

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	iap?: [...#RegionBackendServiceIapParameters] @go(Iap,[]RegionBackendServiceIapParameters)

	// is set to INTERNAL_MANAGED
	// +kubebuilder:validation:Optional
	loadBalancingScheme?: null | string @go(LoadBalancingScheme,*string)

	// is set to MAGLEV or RING_HASH
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	localityLbPolicy?: null | string @go(LocalityLBPolicy,*string)

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	logConfig?: [...#RegionBackendServiceLogConfigParameters] @go(LogConfig,[]RegionBackendServiceLogConfigParameters)

	// The URL of the network to which this backend service belongs.
	// This field can only be specified when the load balancing scheme is set to INTERNAL.
	// +kubebuilder:validation:Optional
	network?: null | string @go(Network,*string)

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_MANAGED and the protocol is set to HTTP, HTTPS, or HTTP2.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	outlierDetection?: [...#RegionBackendServiceOutlierDetectionParameters] @go(OutlierDetection,[]RegionBackendServiceOutlierDetectionParameters)

	// A named port on a backend instance group representing the port for
	// communication to the backend VMs in that group. Required when the
	// loadBalancingScheme is EXTERNAL, EXTERNAL_MANAGED, INTERNAL_MANAGED, or INTERNAL_SELF_MANAGED
	// and the backends are instance groups. The named port must be defined on each
	// backend instance group. This parameter has no meaning if the backends are NEGs. API sets a
	// default of "http" if not given.
	// Must be omitted when the loadBalancingScheme is INTERNAL (Internal TCP/UDP Load Balancing).
	// +kubebuilder:validation:Optional
	portName?: null | string @go(PortName,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// is set to HTTP, HTTPS, or HTTP2
	// +kubebuilder:validation:Optional
	protocol?: null | string @go(Protocol,*string)

	// The Region in which the created backend service should reside.
	// If it is not provided, the provider region is used.
	// +kubebuilder:validation:Required
	region?: null | string @go(Region,*string)

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE, CLIENT_IP_NO_DESTINATION.
	// +kubebuilder:validation:Optional
	sessionAffinity?: null | string @go(SessionAffinity,*string)

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	// +kubebuilder:validation:Optional
	timeoutSec?: null | float64 @go(TimeoutSec,*float64)
}

// RegionBackendServiceSpec defines the desired state of RegionBackendService
#RegionBackendServiceSpec: {
	v1.#ResourceSpec
	forProvider: #RegionBackendServiceParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #RegionBackendServiceInitParameters @go(InitProvider)
}

// RegionBackendServiceStatus defines the observed state of RegionBackendService.
#RegionBackendServiceStatus: {
	v1.#ResourceStatus
	atProvider?: #RegionBackendServiceObservation @go(AtProvider)
}

// RegionBackendService is the Schema for the RegionBackendServices API. A Region Backend Service defines a regionally-scoped group of virtual machines that will serve traffic for load balancing.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#RegionBackendService: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta          @go(ObjectMeta)
	spec:      #RegionBackendServiceSpec   @go(Spec)
	status?:   #RegionBackendServiceStatus @go(Status)
}

// RegionBackendServiceList contains a list of RegionBackendServices
#RegionBackendServiceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#RegionBackendService] @go(Items,[]RegionBackendService)
}
