// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-gcp/apis/compute/v1beta1

package v1beta1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#BackendInitParameters: {
	// Specifies the balancing mode for this backend.
	// For global HTTP(S) or TCP/SSL load balancing, the default is
	// UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
	// and CONNECTION (for TCP/SSL).
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	balancingMode?: null | string @go(BalancingMode,*string)

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// Default value is 1, which means the group will serve up to 100%
	// of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	capacityScaler?: null | float64 @go(CapacityScaler,*float64)

	// An optional description of this resource.
	// Provide this property when you create the resource.
	description?: null | string @go(Description,*string)

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either
	// maxConnections or maxConnectionsPerEndpoint must be set.
	maxConnectionsPerEndpoint?: null | float64 @go(MaxConnectionsPerEndpoint,*float64)

	// The max number of simultaneous connections that a single
	// backend instance can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	maxConnectionsPerInstance?: null | float64 @go(MaxConnectionsPerInstance,*float64)

	// The max requests per second (RPS) of the group.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. For RATE mode, either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	maxRate?: null | float64 @go(MaxRate,*float64)

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set.
	maxRatePerEndpoint?: null | float64 @go(MaxRatePerEndpoint,*float64)

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set.
	maxRatePerInstance?: null | float64 @go(MaxRatePerInstance,*float64)

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	maxUtilization?: null | float64 @go(MaxUtilization,*float64)
}

#BackendObservation: {
	// Specifies the balancing mode for this backend.
	// For global HTTP(S) or TCP/SSL load balancing, the default is
	// UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
	// and CONNECTION (for TCP/SSL).
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	balancingMode?: null | string @go(BalancingMode,*string)

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// Default value is 1, which means the group will serve up to 100%
	// of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	capacityScaler?: null | float64 @go(CapacityScaler,*float64)

	// An optional description of this resource.
	// Provide this property when you create the resource.
	description?: null | string @go(Description,*string)

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	group?: null | string @go(Group,*string)

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either
	// maxConnections or maxConnectionsPerEndpoint must be set.
	maxConnectionsPerEndpoint?: null | float64 @go(MaxConnectionsPerEndpoint,*float64)

	// The max number of simultaneous connections that a single
	// backend instance can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	maxConnectionsPerInstance?: null | float64 @go(MaxConnectionsPerInstance,*float64)

	// The max requests per second (RPS) of the group.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. For RATE mode, either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	maxRate?: null | float64 @go(MaxRate,*float64)

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set.
	maxRatePerEndpoint?: null | float64 @go(MaxRatePerEndpoint,*float64)

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set.
	maxRatePerInstance?: null | float64 @go(MaxRatePerInstance,*float64)

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	maxUtilization?: null | float64 @go(MaxUtilization,*float64)
}

#BackendParameters: {
	// Specifies the balancing mode for this backend.
	// For global HTTP(S) or TCP/SSL load balancing, the default is
	// UTILIZATION. Valid values are UTILIZATION, RATE (for HTTP(S))
	// and CONNECTION (for TCP/SSL).
	// See the Backend Services Overview
	// for an explanation of load balancing modes.
	// Default value is UTILIZATION.
	// Possible values are: UTILIZATION, RATE, CONNECTION.
	// +kubebuilder:validation:Optional
	balancingMode?: null | string @go(BalancingMode,*string)

	// A multiplier applied to the group's maximum servicing capacity
	// (based on UTILIZATION, RATE or CONNECTION).
	// Default value is 1, which means the group will serve up to 100%
	// of its configured capacity (depending on balancingMode). A
	// setting of 0 means the group is completely drained, offering
	// 0% of its available Capacity. Valid range is [0.0,1.0].
	// +kubebuilder:validation:Optional
	capacityScaler?: null | float64 @go(CapacityScaler,*float64)

	// An optional description of this resource.
	// Provide this property when you create the resource.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// The fully-qualified URL of an Instance Group or Network Endpoint
	// Group resource. In case of instance group this defines the list
	// of instances that serve traffic. Member virtual machine
	// instances from each instance group must live in the same zone as
	// the instance group itself. No two backends in a backend service
	// are allowed to use same Instance Group resource.
	// For Network Endpoint Groups this defines list of endpoints. All
	// endpoints of Network Endpoint Group must be hosted on instances
	// located in the same zone as the Network Endpoint Group.
	// Backend services cannot mix Instance Group and
	// Network Endpoint Group backends.
	// Note that you must specify an Instance Group or Network Endpoint
	// Group resource using the fully-qualified URL, rather than a
	// partial URL.
	// +crossplane:generate:reference:type=InstanceGroupManager
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/compute.InstanceGroupExtractor()
	// +kubebuilder:validation:Optional
	group?: null | string @go(Group,*string)

	// Reference to a InstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	groupRef?: null | v1.#Reference @go(GroupRef,*v1.Reference)

	// Selector for a InstanceGroupManager to populate group.
	// +kubebuilder:validation:Optional
	groupSelector?: null | v1.#Selector @go(GroupSelector,*v1.Selector)

	// The max number of simultaneous connections for the group. Can
	// be used with either CONNECTION or UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or one
	// of maxConnectionsPerInstance or maxConnectionsPerEndpoint,
	// as appropriate for group type, must be set.
	// +kubebuilder:validation:Optional
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either
	// maxConnections or maxConnectionsPerEndpoint must be set.
	// +kubebuilder:validation:Optional
	maxConnectionsPerEndpoint?: null | float64 @go(MaxConnectionsPerEndpoint,*float64)

	// The max number of simultaneous connections that a single
	// backend instance can handle. This is used to calculate the
	// capacity of the group. Can be used in either CONNECTION or
	// UTILIZATION balancing modes.
	// For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	// +kubebuilder:validation:Optional
	maxConnectionsPerInstance?: null | float64 @go(MaxConnectionsPerInstance,*float64)

	// The max requests per second (RPS) of the group.
	// Can be used with either RATE or UTILIZATION balancing modes,
	// but required if RATE mode. For RATE mode, either maxRate or one
	// of maxRatePerInstance or maxRatePerEndpoint, as appropriate for
	// group type, must be set.
	// +kubebuilder:validation:Optional
	maxRate?: null | float64 @go(MaxRate,*float64)

	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerEndpoint must be set.
	// +kubebuilder:validation:Optional
	maxRatePerEndpoint?: null | float64 @go(MaxRatePerEndpoint,*float64)

	// The max requests per second (RPS) that a single backend
	// instance can handle. This is used to calculate the capacity of
	// the group. Can be used in either balancing mode. For RATE mode,
	// either maxRate or maxRatePerInstance must be set.
	// +kubebuilder:validation:Optional
	maxRatePerInstance?: null | float64 @go(MaxRatePerInstance,*float64)

	// Used when balancingMode is UTILIZATION. This ratio defines the
	// CPU utilization target for the group. Valid range is [0.0, 1.0].
	// +kubebuilder:validation:Optional
	maxUtilization?: null | float64 @go(MaxUtilization,*float64)
}

#BackendServiceCdnPolicyInitParameters: {
	// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
	// The cache is bypassed for all cdnPolicy.cacheMode settings.
	// Structure is documented below.
	bypassCacheOnRequestHeaders?: [...#CdnPolicyBypassCacheOnRequestHeadersInitParameters] @go(BypassCacheOnRequestHeaders,[]CdnPolicyBypassCacheOnRequestHeadersInitParameters)

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	cacheKeyPolicy?: [...#CdnPolicyCacheKeyPolicyInitParameters] @go(CacheKeyPolicy,[]CdnPolicyCacheKeyPolicyInitParameters)

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	cacheMode?: null | string @go(CacheMode,*string)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	clientTtl?: null | float64 @go(ClientTTL,*float64)

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	defaultTtl?: null | float64 @go(DefaultTTL,*float64)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	maxTtl?: null | float64 @go(MaxTTL,*float64)

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	negativeCaching?: null | bool @go(NegativeCaching,*bool)

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	negativeCachingPolicy?: [...#CdnPolicyNegativeCachingPolicyInitParameters] @go(NegativeCachingPolicy,[]CdnPolicyNegativeCachingPolicyInitParameters)

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	serveWhileStale?: null | float64 @go(ServeWhileStale,*float64)

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	signedUrlCacheMaxAgeSec?: null | float64 @go(SignedURLCacheMaxAgeSec,*float64)
}

#BackendServiceCdnPolicyObservation: {
	// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
	// The cache is bypassed for all cdnPolicy.cacheMode settings.
	// Structure is documented below.
	bypassCacheOnRequestHeaders?: [...#CdnPolicyBypassCacheOnRequestHeadersObservation] @go(BypassCacheOnRequestHeaders,[]CdnPolicyBypassCacheOnRequestHeadersObservation)

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	cacheKeyPolicy?: [...#CdnPolicyCacheKeyPolicyObservation] @go(CacheKeyPolicy,[]CdnPolicyCacheKeyPolicyObservation)

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	cacheMode?: null | string @go(CacheMode,*string)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	clientTtl?: null | float64 @go(ClientTTL,*float64)

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	defaultTtl?: null | float64 @go(DefaultTTL,*float64)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	maxTtl?: null | float64 @go(MaxTTL,*float64)

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	negativeCaching?: null | bool @go(NegativeCaching,*bool)

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	negativeCachingPolicy?: [...#CdnPolicyNegativeCachingPolicyObservation] @go(NegativeCachingPolicy,[]CdnPolicyNegativeCachingPolicyObservation)

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	serveWhileStale?: null | float64 @go(ServeWhileStale,*float64)

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	signedUrlCacheMaxAgeSec?: null | float64 @go(SignedURLCacheMaxAgeSec,*float64)
}

#BackendServiceCdnPolicyParameters: {
	// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified.
	// The cache is bypassed for all cdnPolicy.cacheMode settings.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	bypassCacheOnRequestHeaders?: [...#CdnPolicyBypassCacheOnRequestHeadersParameters] @go(BypassCacheOnRequestHeaders,[]CdnPolicyBypassCacheOnRequestHeadersParameters)

	// The CacheKeyPolicy for this CdnPolicy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cacheKeyPolicy?: [...#CdnPolicyCacheKeyPolicyParameters] @go(CacheKeyPolicy,[]CdnPolicyCacheKeyPolicyParameters)

	// Specifies the cache setting for all responses from this backend.
	// The possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL and CACHE_ALL_STATIC
	// Possible values are: USE_ORIGIN_HEADERS, FORCE_CACHE_ALL, CACHE_ALL_STATIC.
	// +kubebuilder:validation:Optional
	cacheMode?: null | string @go(CacheMode,*string)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	clientTtl?: null | float64 @go(ClientTTL,*float64)

	// Specifies the default TTL for cached content served by this origin for responses
	// that do not have an existing valid TTL (max-age or s-max-age).
	// +kubebuilder:validation:Optional
	defaultTtl?: null | float64 @go(DefaultTTL,*float64)

	// Specifies the maximum allowed TTL for cached content served by this origin.
	// +kubebuilder:validation:Optional
	maxTtl?: null | float64 @go(MaxTTL,*float64)

	// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects.
	// +kubebuilder:validation:Optional
	negativeCaching?: null | bool @go(NegativeCaching,*bool)

	// Sets a cache TTL for the specified HTTP status code. negativeCaching must be enabled to configure negativeCachingPolicy.
	// Omitting the policy and leaving negativeCaching enabled will use Cloud CDN's default cache TTLs.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	negativeCachingPolicy?: [...#CdnPolicyNegativeCachingPolicyParameters] @go(NegativeCachingPolicy,[]CdnPolicyNegativeCachingPolicyParameters)

	// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache.
	// +kubebuilder:validation:Optional
	serveWhileStale?: null | float64 @go(ServeWhileStale,*float64)

	// Maximum number of seconds the response to a signed URL request
	// will be considered fresh, defaults to 1hr (3600s). After this
	// time period, the response will be revalidated before
	// being served.
	// When serving responses to signed URL requests, Cloud CDN will
	// internally behave as though all responses from this backend had a
	// "Cache-Control: public, max-age=[TTL]" header, regardless of any
	// existing Cache-Control header. The actual headers served in
	// responses will not be altered.
	// +kubebuilder:validation:Optional
	signedUrlCacheMaxAgeSec?: null | float64 @go(SignedURLCacheMaxAgeSec,*float64)
}

#BackendServiceInitParameters: {
	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	affinityCookieTtlSec?: null | float64 @go(AffinityCookieTTLSec,*float64)

	// The set of backends that serve this BackendService.
	// Structure is documented below.
	backend?: [...#BackendInitParameters] @go(Backend,[]BackendInitParameters)

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	cdnPolicy?: [...#BackendServiceCdnPolicyInitParameters] @go(CdnPolicy,[]BackendServiceCdnPolicyInitParameters)

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	circuitBreakers?: [...#CircuitBreakersInitParameters] @go(CircuitBreakers,[]CircuitBreakersInitParameters)

	// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
	// Possible values are: AUTOMATIC, DISABLED.
	compressionMode?: null | string @go(CompressionMode,*string)

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	connectionDrainingTimeoutSec?: null | float64 @go(ConnectionDrainingTimeoutSec,*float64)

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing. This field only applies if the load_balancing_scheme is set to
	// INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
	// set to MAGLEV or RING_HASH.
	// Structure is documented below.
	consistentHash?: [...#ConsistentHashInitParameters] @go(ConsistentHash,[]ConsistentHashInitParameters)

	// Headers that the HTTP/S load balancer should add to proxied
	// requests.
	customRequestHeaders?: [...null | string] @go(CustomRequestHeaders,[]*string)

	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	customResponseHeaders?: [...null | string] @go(CustomResponseHeaders,[]*string)

	// An optional description of this resource.
	description?: null | string @go(Description,*string)

	// The resource URL for the edge security policy associated with this backend service.
	edgeSecurityPolicy?: null | string @go(EdgeSecurityPolicy,*string)

	// If true, enable Cloud CDN for this BackendService.
	enableCdn?: null | bool @go(EnableCdn,*bool)

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	iap?: [...#IapInitParameters] @go(Iap,[]IapInitParameters)

	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. For more information, refer to
	// Choosing a load balancer.
	// Default value is EXTERNAL.
	// Possible values are: EXTERNAL, INTERNAL_SELF_MANAGED, EXTERNAL_MANAGED.
	loadBalancingScheme?: null | string @go(LoadBalancingScheme,*string)

	// A list of locality load balancing policies to be used in order of
	// preference. Either the policy or the customPolicy field should be set.
	// Overrides any value set in the localityLbPolicy field.
	// localityLbPolicies is only supported when the BackendService is referenced
	// by a URL Map that is referenced by a target gRPC proxy that has the
	// validateForProxyless field set to true.
	// Structure is documented below.
	localityLbPolicies?: [...#LocalityLBPoliciesInitParameters] @go(LocalityLBPolicies,[]LocalityLBPoliciesInitParameters)

	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	localityLbPolicy?: null | string @go(LocalityLBPolicy,*string)

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	logConfig?: [...#LogConfigInitParameters] @go(LogConfig,[]LogConfigInitParameters)

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	outlierDetection?: [...#OutlierDetectionInitParameters] @go(OutlierDetection,[]OutlierDetectionInitParameters)

	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	portName?: null | string @go(PortName,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// The protocol this BackendService uses to communicate with backends.
	// The default is HTTP. NOTE: HTTP2 is only valid for beta HTTP/2 load balancer
	// types and may result in errors if used with the GA API.
	// Possible values are: HTTP, HTTPS, HTTP2, TCP, SSL, GRPC.
	protocol?: null | string @go(Protocol,*string)

	// The security policy associated with this backend service.
	securityPolicy?: null | string @go(SecurityPolicy,*string)

	// The security settings that apply to this backend service. This field is applicable to either
	// a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	securitySettings?: [...#SecuritySettingsInitParameters] @go(SecuritySettings,[]SecuritySettingsInitParameters)

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE.
	sessionAffinity?: null | string @go(SessionAffinity,*string)

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	timeoutSec?: null | float64 @go(TimeoutSec,*float64)
}

#BackendServiceObservation: {
	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	affinityCookieTtlSec?: null | float64 @go(AffinityCookieTTLSec,*float64)

	// The set of backends that serve this BackendService.
	// Structure is documented below.
	backend?: [...#BackendObservation] @go(Backend,[]BackendObservation)

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	cdnPolicy?: [...#BackendServiceCdnPolicyObservation] @go(CdnPolicy,[]BackendServiceCdnPolicyObservation)

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	circuitBreakers?: [...#CircuitBreakersObservation] @go(CircuitBreakers,[]CircuitBreakersObservation)

	// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
	// Possible values are: AUTOMATIC, DISABLED.
	compressionMode?: null | string @go(CompressionMode,*string)

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	connectionDrainingTimeoutSec?: null | float64 @go(ConnectionDrainingTimeoutSec,*float64)

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing. This field only applies if the load_balancing_scheme is set to
	// INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
	// set to MAGLEV or RING_HASH.
	// Structure is documented below.
	consistentHash?: [...#ConsistentHashObservation] @go(ConsistentHash,[]ConsistentHashObservation)

	// Creation timestamp in RFC3339 text format.
	creationTimestamp?: null | string @go(CreationTimestamp,*string)

	// Headers that the HTTP/S load balancer should add to proxied
	// requests.
	customRequestHeaders?: [...null | string] @go(CustomRequestHeaders,[]*string)

	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	customResponseHeaders?: [...null | string] @go(CustomResponseHeaders,[]*string)

	// An optional description of this resource.
	description?: null | string @go(Description,*string)

	// The resource URL for the edge security policy associated with this backend service.
	edgeSecurityPolicy?: null | string @go(EdgeSecurityPolicy,*string)

	// If true, enable Cloud CDN for this BackendService.
	enableCdn?: null | bool @go(EnableCdn,*bool)

	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking.
	fingerprint?: null | string @go(Fingerprint,*string)

	// The unique identifier for the resource. This identifier is defined by the server.
	generatedId?: null | float64 @go(GeneratedID,*float64)

	// The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
	// for health checking this BackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// For internal load balancing, a URL to a HealthCheck resource must be specified instead.
	healthChecks?: [...null | string] @go(HealthChecks,[]*string)

	// an identifier for the resource with format projects/{{project}}/global/backendServices/{{name}}
	id?: null | string @go(ID,*string)

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	iap?: [...#IapObservation] @go(Iap,[]IapObservation)

	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. For more information, refer to
	// Choosing a load balancer.
	// Default value is EXTERNAL.
	// Possible values are: EXTERNAL, INTERNAL_SELF_MANAGED, EXTERNAL_MANAGED.
	loadBalancingScheme?: null | string @go(LoadBalancingScheme,*string)

	// A list of locality load balancing policies to be used in order of
	// preference. Either the policy or the customPolicy field should be set.
	// Overrides any value set in the localityLbPolicy field.
	// localityLbPolicies is only supported when the BackendService is referenced
	// by a URL Map that is referenced by a target gRPC proxy that has the
	// validateForProxyless field set to true.
	// Structure is documented below.
	localityLbPolicies?: [...#LocalityLBPoliciesObservation] @go(LocalityLBPolicies,[]LocalityLBPoliciesObservation)

	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	localityLbPolicy?: null | string @go(LocalityLBPolicy,*string)

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	logConfig?: [...#LogConfigObservation] @go(LogConfig,[]LogConfigObservation)

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	outlierDetection?: [...#OutlierDetectionObservation] @go(OutlierDetection,[]OutlierDetectionObservation)

	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	portName?: null | string @go(PortName,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	project?: null | string @go(Project,*string)

	// The protocol this BackendService uses to communicate with backends.
	// The default is HTTP. NOTE: HTTP2 is only valid for beta HTTP/2 load balancer
	// types and may result in errors if used with the GA API.
	// Possible values are: HTTP, HTTPS, HTTP2, TCP, SSL, GRPC.
	protocol?: null | string @go(Protocol,*string)

	// The security policy associated with this backend service.
	securityPolicy?: null | string @go(SecurityPolicy,*string)

	// The security settings that apply to this backend service. This field is applicable to either
	// a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	securitySettings?: [...#SecuritySettingsObservation] @go(SecuritySettings,[]SecuritySettingsObservation)

	// The URI of the created resource.
	selfLink?: null | string @go(SelfLink,*string)

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE.
	sessionAffinity?: null | string @go(SessionAffinity,*string)

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	timeoutSec?: null | float64 @go(TimeoutSec,*float64)
}

#BackendServiceParameters: {
	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	// When the load balancing scheme is INTERNAL, this field is not used.
	// +kubebuilder:validation:Optional
	affinityCookieTtlSec?: null | float64 @go(AffinityCookieTTLSec,*float64)

	// The set of backends that serve this BackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	backend?: [...#BackendParameters] @go(Backend,[]BackendParameters)

	// Cloud CDN configuration for this BackendService.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	cdnPolicy?: [...#BackendServiceCdnPolicyParameters] @go(CdnPolicy,[]BackendServiceCdnPolicyParameters)

	// Settings controlling the volume of connections to a backend service. This field
	// is applicable only when the load_balancing_scheme is set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	circuitBreakers?: [...#CircuitBreakersParameters] @go(CircuitBreakers,[]CircuitBreakersParameters)

	// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
	// Possible values are: AUTOMATIC, DISABLED.
	// +kubebuilder:validation:Optional
	compressionMode?: null | string @go(CompressionMode,*string)

	// Time for which instance will be drained (not accept new
	// connections, but still work to finish started).
	// +kubebuilder:validation:Optional
	connectionDrainingTimeoutSec?: null | float64 @go(ConnectionDrainingTimeoutSec,*float64)

	// Consistent Hash-based load balancing can be used to provide soft session
	// affinity based on HTTP headers, cookies or other properties. This load balancing
	// policy is applicable only for HTTP connections. The affinity to a particular
	// destination host will be lost when one or more hosts are added/removed from the
	// destination service. This field specifies parameters that control consistent
	// hashing. This field only applies if the load_balancing_scheme is set to
	// INTERNAL_SELF_MANAGED. This field is only applicable when locality_lb_policy is
	// set to MAGLEV or RING_HASH.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	consistentHash?: [...#ConsistentHashParameters] @go(ConsistentHash,[]ConsistentHashParameters)

	// Headers that the HTTP/S load balancer should add to proxied
	// requests.
	// +kubebuilder:validation:Optional
	customRequestHeaders?: [...null | string] @go(CustomRequestHeaders,[]*string)

	// Headers that the HTTP/S load balancer should add to proxied
	// responses.
	// +kubebuilder:validation:Optional
	customResponseHeaders?: [...null | string] @go(CustomResponseHeaders,[]*string)

	// An optional description of this resource.
	// +kubebuilder:validation:Optional
	description?: null | string @go(Description,*string)

	// The resource URL for the edge security policy associated with this backend service.
	// +kubebuilder:validation:Optional
	edgeSecurityPolicy?: null | string @go(EdgeSecurityPolicy,*string)

	// If true, enable Cloud CDN for this BackendService.
	// +kubebuilder:validation:Optional
	enableCdn?: null | bool @go(EnableCdn,*bool)

	// The set of URLs to the HttpHealthCheck or HttpsHealthCheck resource
	// for health checking this BackendService. Currently at most one health
	// check can be specified.
	// A health check must be specified unless the backend service uses an internet
	// or serverless NEG as a backend.
	// For internal load balancing, a URL to a HealthCheck resource must be specified instead.
	// +crossplane:generate:reference:type=HealthCheck
	// +crossplane:generate:reference:extractor=github.com/upbound/provider-gcp/config/common.SelfLinkExtractor()
	// +kubebuilder:validation:Optional
	healthChecks?: [...null | string] @go(HealthChecks,[]*string)

	// References to HealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	healthChecksRefs?: [...v1.#Reference] @go(HealthChecksRefs,[]v1.Reference)

	// Selector for a list of HealthCheck to populate healthChecks.
	// +kubebuilder:validation:Optional
	healthChecksSelector?: null | v1.#Selector @go(HealthChecksSelector,*v1.Selector)

	// Settings for enabling Cloud Identity Aware Proxy
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	iap?: [...#IapParameters] @go(Iap,[]IapParameters)

	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. For more information, refer to
	// Choosing a load balancer.
	// Default value is EXTERNAL.
	// Possible values are: EXTERNAL, INTERNAL_SELF_MANAGED, EXTERNAL_MANAGED.
	// +kubebuilder:validation:Optional
	loadBalancingScheme?: null | string @go(LoadBalancingScheme,*string)

	// A list of locality load balancing policies to be used in order of
	// preference. Either the policy or the customPolicy field should be set.
	// Overrides any value set in the localityLbPolicy field.
	// localityLbPolicies is only supported when the BackendService is referenced
	// by a URL Map that is referenced by a target gRPC proxy that has the
	// validateForProxyless field set to true.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	localityLbPolicies?: [...#LocalityLBPoliciesParameters] @go(LocalityLBPolicies,[]LocalityLBPoliciesParameters)

	// The load balancing algorithm used within the scope of the locality.
	// The possible values are:
	// +kubebuilder:validation:Optional
	localityLbPolicy?: null | string @go(LocalityLBPolicy,*string)

	// This field denotes the logging options for the load balancer traffic served by this backend service.
	// If logging is enabled, logs will be exported to Stackdriver.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	logConfig?: [...#LogConfigParameters] @go(LogConfig,[]LogConfigParameters)

	// Settings controlling eviction of unhealthy hosts from the load balancing pool.
	// This field is applicable only when the load_balancing_scheme is set
	// to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	outlierDetection?: [...#OutlierDetectionParameters] @go(OutlierDetection,[]OutlierDetectionParameters)

	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	// +kubebuilder:validation:Optional
	portName?: null | string @go(PortName,*string)

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +kubebuilder:validation:Optional
	project?: null | string @go(Project,*string)

	// The protocol this BackendService uses to communicate with backends.
	// The default is HTTP. NOTE: HTTP2 is only valid for beta HTTP/2 load balancer
	// types and may result in errors if used with the GA API.
	// Possible values are: HTTP, HTTPS, HTTP2, TCP, SSL, GRPC.
	// +kubebuilder:validation:Optional
	protocol?: null | string @go(Protocol,*string)

	// The security policy associated with this backend service.
	// +kubebuilder:validation:Optional
	securityPolicy?: null | string @go(SecurityPolicy,*string)

	// The security settings that apply to this backend service. This field is applicable to either
	// a regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and
	// load_balancing_scheme set to INTERNAL_MANAGED; or a global backend service with the
	// load_balancing_scheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	securitySettings?: [...#SecuritySettingsParameters] @go(SecuritySettings,[]SecuritySettingsParameters)

	// Type of session affinity to use. The default is NONE. Session affinity is
	// not applicable if the protocol is UDP.
	// Possible values are: NONE, CLIENT_IP, CLIENT_IP_PORT_PROTO, CLIENT_IP_PROTO, GENERATED_COOKIE, HEADER_FIELD, HTTP_COOKIE.
	// +kubebuilder:validation:Optional
	sessionAffinity?: null | string @go(SessionAffinity,*string)

	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds. Valid range is [1, 86400].
	// +kubebuilder:validation:Optional
	timeoutSec?: null | float64 @go(TimeoutSec,*float64)
}

#BaseEjectionTimeInitParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#BaseEjectionTimeObservation: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#BaseEjectionTimeParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	seconds?: null | float64 @go(Seconds,*float64)
}

#CdnPolicyBypassCacheOnRequestHeadersInitParameters: {
	// The header field name to match on when bypassing cache. Values are case-insensitive.
	headerName?: null | string @go(HeaderName,*string)
}

#CdnPolicyBypassCacheOnRequestHeadersObservation: {
	// The header field name to match on when bypassing cache. Values are case-insensitive.
	headerName?: null | string @go(HeaderName,*string)
}

#CdnPolicyBypassCacheOnRequestHeadersParameters: {
	// The header field name to match on when bypassing cache. Values are case-insensitive.
	// +kubebuilder:validation:Optional
	headerName?: null | string @go(HeaderName,*string)
}

#CdnPolicyCacheKeyPolicyInitParameters: {
	// Allows HTTP request headers (by name) to be used in the
	// cache key.
	includeHttpHeaders?: [...null | string] @go(IncludeHTTPHeaders,[]*string)

	// If true requests to different hosts will be cached separately.
	includeHost?: null | bool @go(IncludeHost,*bool)

	// Names of cookies to include in cache keys.
	includeNamedCookies?: [...null | string] @go(IncludeNamedCookies,[]*string)

	// If true, http and https requests will be cached separately.
	includeProtocol?: null | bool @go(IncludeProtocol,*bool)

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	includeQueryString?: null | bool @go(IncludeQueryString,*bool)

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringBlacklist?: [...null | string] @go(QueryStringBlacklist,[]*string)

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringWhitelist?: [...null | string] @go(QueryStringWhitelist,[]*string)
}

#CdnPolicyCacheKeyPolicyObservation: {
	// Allows HTTP request headers (by name) to be used in the
	// cache key.
	includeHttpHeaders?: [...null | string] @go(IncludeHTTPHeaders,[]*string)

	// If true requests to different hosts will be cached separately.
	includeHost?: null | bool @go(IncludeHost,*bool)

	// Names of cookies to include in cache keys.
	includeNamedCookies?: [...null | string] @go(IncludeNamedCookies,[]*string)

	// If true, http and https requests will be cached separately.
	includeProtocol?: null | bool @go(IncludeProtocol,*bool)

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	includeQueryString?: null | bool @go(IncludeQueryString,*bool)

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringBlacklist?: [...null | string] @go(QueryStringBlacklist,[]*string)

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	queryStringWhitelist?: [...null | string] @go(QueryStringWhitelist,[]*string)
}

#CdnPolicyCacheKeyPolicyParameters: {
	// Allows HTTP request headers (by name) to be used in the
	// cache key.
	// +kubebuilder:validation:Optional
	includeHttpHeaders?: [...null | string] @go(IncludeHTTPHeaders,[]*string)

	// If true requests to different hosts will be cached separately.
	// +kubebuilder:validation:Optional
	includeHost?: null | bool @go(IncludeHost,*bool)

	// Names of cookies to include in cache keys.
	// +kubebuilder:validation:Optional
	includeNamedCookies?: [...null | string] @go(IncludeNamedCookies,[]*string)

	// If true, http and https requests will be cached separately.
	// +kubebuilder:validation:Optional
	includeProtocol?: null | bool @go(IncludeProtocol,*bool)

	// If true, include query string parameters in the cache key
	// according to query_string_whitelist and
	// query_string_blacklist. If neither is set, the entire query
	// string will be included.
	// If false, the query string will be excluded from the cache
	// key entirely.
	// +kubebuilder:validation:Optional
	includeQueryString?: null | bool @go(IncludeQueryString,*bool)

	// Names of query string parameters to exclude in cache keys.
	// All other parameters will be included. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	queryStringBlacklist?: [...null | string] @go(QueryStringBlacklist,[]*string)

	// Names of query string parameters to include in cache keys.
	// All other parameters will be excluded. Either specify
	// query_string_whitelist or query_string_blacklist, not both.
	// '&' and '=' will be percent encoded and not treated as
	// delimiters.
	// +kubebuilder:validation:Optional
	queryStringWhitelist?: [...null | string] @go(QueryStringWhitelist,[]*string)
}

#CdnPolicyNegativeCachingPolicyInitParameters: {
	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	code?: null | float64 @go(Code,*float64)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	ttl?: null | float64 @go(TTL,*float64)
}

#CdnPolicyNegativeCachingPolicyObservation: {
	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	code?: null | float64 @go(Code,*float64)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	ttl?: null | float64 @go(TTL,*float64)
}

#CdnPolicyNegativeCachingPolicyParameters: {
	// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 308, 404, 405, 410, 421, 451 and 501
	// can be specified as values, and you cannot specify a status code more than once.
	// +kubebuilder:validation:Optional
	code?: null | float64 @go(Code,*float64)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	// +kubebuilder:validation:Optional
	ttl?: null | float64 @go(TTL,*float64)
}

#CircuitBreakersInitParameters: {
	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	maxRequests?: null | float64 @go(MaxRequests,*float64)

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	maxRequestsPerConnection?: null | float64 @go(MaxRequestsPerConnection,*float64)

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	maxRetries?: null | float64 @go(MaxRetries,*float64)
}

#CircuitBreakersObservation: {
	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	maxRequests?: null | float64 @go(MaxRequests,*float64)

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	maxRequestsPerConnection?: null | float64 @go(MaxRequestsPerConnection,*float64)

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	maxRetries?: null | float64 @go(MaxRetries,*float64)
}

#CircuitBreakersParameters: {
	// The maximum number of connections to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	maxConnections?: null | float64 @go(MaxConnections,*float64)

	// The maximum number of pending requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	maxPendingRequests?: null | float64 @go(MaxPendingRequests,*float64)

	// The maximum number of parallel requests to the backend cluster.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	maxRequests?: null | float64 @go(MaxRequests,*float64)

	// Maximum requests for a single backend connection. This parameter
	// is respected by both the HTTP/1.1 and HTTP/2 implementations. If
	// not specified, there is no limit. Setting this parameter to 1
	// will effectively disable keep alive.
	// +kubebuilder:validation:Optional
	maxRequestsPerConnection?: null | float64 @go(MaxRequestsPerConnection,*float64)

	// The maximum number of parallel retries to the backend cluster.
	// Defaults to 3.
	// +kubebuilder:validation:Optional
	maxRetries?: null | float64 @go(MaxRetries,*float64)
}

#ConsistentHashInitParameters: {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	httpCookie?: [...#HTTPCookieInitParameters] @go(HTTPCookie,[]HTTPCookieInitParameters)

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	httpHeaderName?: null | string @go(HTTPHeaderName,*string)

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	minimumRingSize?: null | float64 @go(MinimumRingSize,*float64)
}

#ConsistentHashObservation: {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	httpCookie?: [...#HTTPCookieObservation] @go(HTTPCookie,[]HTTPCookieObservation)

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	httpHeaderName?: null | string @go(HTTPHeaderName,*string)

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	minimumRingSize?: null | float64 @go(MinimumRingSize,*float64)
}

#ConsistentHashParameters: {
	// Hash is based on HTTP Cookie. This field describes a HTTP cookie
	// that will be used as the hash key for the consistent hash load
	// balancer. If the cookie is not present, it will be generated.
	// This field is applicable if the sessionAffinity is set to HTTP_COOKIE.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	httpCookie?: [...#HTTPCookieParameters] @go(HTTPCookie,[]HTTPCookieParameters)

	// The hash based on the value of the specified header field.
	// This field is applicable if the sessionAffinity is set to HEADER_FIELD.
	// +kubebuilder:validation:Optional
	httpHeaderName?: null | string @go(HTTPHeaderName,*string)

	// The minimum number of virtual nodes to use for the hash ring.
	// Larger ring sizes result in more granular load
	// distributions. If the number of hosts in the load balancing pool
	// is larger than the ring size, each host will be assigned a single
	// virtual node.
	// Defaults to 1024.
	// +kubebuilder:validation:Optional
	minimumRingSize?: null | float64 @go(MinimumRingSize,*float64)
}

#CustomPolicyInitParameters: {
	// An optional, arbitrary JSON object with configuration data, understood
	// by a locally installed custom policy implementation.
	data?: null | string @go(Data,*string)

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	name?: null | string @go(Name,*string)
}

#CustomPolicyObservation: {
	// An optional, arbitrary JSON object with configuration data, understood
	// by a locally installed custom policy implementation.
	data?: null | string @go(Data,*string)

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	name?: null | string @go(Name,*string)
}

#CustomPolicyParameters: {
	// An optional, arbitrary JSON object with configuration data, understood
	// by a locally installed custom policy implementation.
	// +kubebuilder:validation:Optional
	data?: null | string @go(Data,*string)

	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#HTTPCookieInitParameters: {
	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	name?: null | string @go(Name,*string)

	// Path to set for the cookie.
	path?: null | string @go(Path,*string)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	ttl?: [...#TTLInitParameters] @go(TTL,[]TTLInitParameters)
}

#HTTPCookieObservation: {
	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	name?: null | string @go(Name,*string)

	// Path to set for the cookie.
	path?: null | string @go(Path,*string)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	ttl?: [...#TTLObservation] @go(TTL,[]TTLObservation)
}

#HTTPCookieParameters: {
	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)

	// Path to set for the cookie.
	// +kubebuilder:validation:Optional
	path?: null | string @go(Path,*string)

	// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s
	// (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
	// +kubebuilder:validation:Optional
	ttl?: [...#TTLParameters] @go(TTL,[]TTLParameters)
}

#IapInitParameters: {
	// OAuth2 Client ID for IAP
	oauth2ClientId?: null | string @go(Oauth2ClientID,*string)
}

#IapObservation: {
	// OAuth2 Client ID for IAP
	oauth2ClientId?: null | string @go(Oauth2ClientID,*string)
}

#IapParameters: {
	// OAuth2 Client ID for IAP
	// +kubebuilder:validation:Optional
	oauth2ClientId?: null | string @go(Oauth2ClientID,*string)

	// OAuth2 Client Secret for IAP
	// Note: This property is sensitive and will not be displayed in the plan.
	// +kubebuilder:validation:Required
	oauth2ClientSecretSecretRef: v1.#SecretKeySelector @go(Oauth2ClientSecretSecretRef)
}

#IntervalInitParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#IntervalObservation: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#IntervalParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	seconds?: null | float64 @go(Seconds,*float64)
}

#LocalityLBPoliciesInitParameters: {
	// The configuration for a custom policy implemented by the user and
	// deployed with the client.
	// Structure is documented below.
	customPolicy?: [...#CustomPolicyInitParameters] @go(CustomPolicy,[]CustomPolicyInitParameters)

	// The configuration for a built-in load balancing policy.
	// Structure is documented below.
	policy?: [...#PolicyInitParameters] @go(Policy,[]PolicyInitParameters)
}

#LocalityLBPoliciesObservation: {
	// The configuration for a custom policy implemented by the user and
	// deployed with the client.
	// Structure is documented below.
	customPolicy?: [...#CustomPolicyObservation] @go(CustomPolicy,[]CustomPolicyObservation)

	// The configuration for a built-in load balancing policy.
	// Structure is documented below.
	policy?: [...#PolicyObservation] @go(Policy,[]PolicyObservation)
}

#LocalityLBPoliciesParameters: {
	// The configuration for a custom policy implemented by the user and
	// deployed with the client.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	customPolicy?: [...#CustomPolicyParameters] @go(CustomPolicy,[]CustomPolicyParameters)

	// The configuration for a built-in load balancing policy.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	policy?: [...#PolicyParameters] @go(Policy,[]PolicyParameters)
}

#LogConfigInitParameters: {
	// Whether to enable logging for the load balancer traffic served by this backend service.
	enable?: null | bool @go(Enable,*bool)

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	sampleRate?: null | float64 @go(SampleRate,*float64)
}

#LogConfigObservation: {
	// Whether to enable logging for the load balancer traffic served by this backend service.
	enable?: null | bool @go(Enable,*bool)

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	sampleRate?: null | float64 @go(SampleRate,*float64)
}

#LogConfigParameters: {
	// Whether to enable logging for the load balancer traffic served by this backend service.
	// +kubebuilder:validation:Optional
	enable?: null | bool @go(Enable,*bool)

	// This field can only be specified if logging is enabled for this backend service. The value of
	// the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer
	// where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported.
	// The default value is 1.0.
	// +kubebuilder:validation:Optional
	sampleRate?: null | float64 @go(SampleRate,*float64)
}

#OutlierDetectionInitParameters: {
	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	baseEjectionTime?: [...#BaseEjectionTimeInitParameters] @go(BaseEjectionTime,[]BaseEjectionTimeInitParameters)

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	consecutiveErrors?: null | float64 @go(ConsecutiveErrors,*float64)

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	consecutiveGatewayFailure?: null | float64 @go(ConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	enforcingConsecutiveErrors?: null | float64 @go(EnforcingConsecutiveErrors,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	enforcingConsecutiveGatewayFailure?: null | float64 @go(EnforcingConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	enforcingSuccessRate?: null | float64 @go(EnforcingSuccessRate,*float64)

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	interval?: [...#IntervalInitParameters] @go(Interval,[]IntervalInitParameters)

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	successRateMinimumHosts?: null | float64 @go(SuccessRateMinimumHosts,*float64)

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	successRateRequestVolume?: null | float64 @go(SuccessRateRequestVolume,*float64)

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	successRateStdevFactor?: null | float64 @go(SuccessRateStdevFactor,*float64)
}

#OutlierDetectionObservation: {
	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	baseEjectionTime?: [...#BaseEjectionTimeObservation] @go(BaseEjectionTime,[]BaseEjectionTimeObservation)

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	consecutiveErrors?: null | float64 @go(ConsecutiveErrors,*float64)

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	consecutiveGatewayFailure?: null | float64 @go(ConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	enforcingConsecutiveErrors?: null | float64 @go(EnforcingConsecutiveErrors,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	enforcingConsecutiveGatewayFailure?: null | float64 @go(EnforcingConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	enforcingSuccessRate?: null | float64 @go(EnforcingSuccessRate,*float64)

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	interval?: [...#IntervalObservation] @go(Interval,[]IntervalObservation)

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	successRateMinimumHosts?: null | float64 @go(SuccessRateMinimumHosts,*float64)

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	successRateRequestVolume?: null | float64 @go(SuccessRateRequestVolume,*float64)

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	successRateStdevFactor?: null | float64 @go(SuccessRateStdevFactor,*float64)
}

#OutlierDetectionParameters: {
	// The base time that a host is ejected for. The real time is equal to the base
	// time multiplied by the number of times the host has been ejected. Defaults to
	// 30000ms or 30s.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	baseEjectionTime?: [...#BaseEjectionTimeParameters] @go(BaseEjectionTime,[]BaseEjectionTimeParameters)

	// Number of errors before a host is ejected from the connection pool. When the
	// backend host is accessed over HTTP, a 5xx return code qualifies as an error.
	// Defaults to 5.
	// +kubebuilder:validation:Optional
	consecutiveErrors?: null | float64 @go(ConsecutiveErrors,*float64)

	// The number of consecutive gateway failures (502, 503, 504 status or connection
	// errors that are mapped to one of those status codes) before a consecutive
	// gateway failure ejection occurs. Defaults to 5.
	// +kubebuilder:validation:Optional
	consecutiveGatewayFailure?: null | float64 @go(ConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive 5xx. This setting can be used to disable
	// ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	enforcingConsecutiveErrors?: null | float64 @go(EnforcingConsecutiveErrors,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through consecutive gateway failures. This setting can be
	// used to disable ejection or to ramp it up slowly. Defaults to 0.
	// +kubebuilder:validation:Optional
	enforcingConsecutiveGatewayFailure?: null | float64 @go(EnforcingConsecutiveGatewayFailure,*float64)

	// The percentage chance that a host will be actually ejected when an outlier
	// status is detected through success rate statistics. This setting can be used to
	// disable ejection or to ramp it up slowly. Defaults to 100.
	// +kubebuilder:validation:Optional
	enforcingSuccessRate?: null | float64 @go(EnforcingSuccessRate,*float64)

	// Time interval between ejection sweep analysis. This can result in both new
	// ejections as well as hosts being returned to service. Defaults to 10 seconds.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	interval?: [...#IntervalParameters] @go(Interval,[]IntervalParameters)

	// Maximum percentage of hosts in the load balancing pool for the backend service
	// that can be ejected. Defaults to 10%.
	// +kubebuilder:validation:Optional
	maxEjectionPercent?: null | float64 @go(MaxEjectionPercent,*float64)

	// The number of hosts in a cluster that must have enough request volume to detect
	// success rate outliers. If the number of hosts is less than this setting, outlier
	// detection via success rate statistics is not performed for any host in the
	// cluster. Defaults to 5.
	// +kubebuilder:validation:Optional
	successRateMinimumHosts?: null | float64 @go(SuccessRateMinimumHosts,*float64)

	// The minimum number of total requests that must be collected in one interval (as
	// defined by the interval duration above) to include this host in success rate
	// based outlier detection. If the volume is lower than this setting, outlier
	// detection via success rate statistics is not performed for that host. Defaults
	// to 100.
	// +kubebuilder:validation:Optional
	successRateRequestVolume?: null | float64 @go(SuccessRateRequestVolume,*float64)

	// This factor is used to determine the ejection threshold for success rate outlier
	// ejection. The ejection threshold is the difference between the mean success
	// rate, and the product of this factor and the standard deviation of the mean
	// success rate: mean - (stdev * success_rate_stdev_factor). This factor is divided
	// by a thousand to get a double. That is, if the desired factor is 1.9, the
	// runtime value should be 1900. Defaults to 1900.
	// +kubebuilder:validation:Optional
	successRateStdevFactor?: null | float64 @go(SuccessRateStdevFactor,*float64)
}

#PolicyInitParameters: {
	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	name?: null | string @go(Name,*string)
}

#PolicyObservation: {
	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	name?: null | string @go(Name,*string)
}

#PolicyParameters: {
	// The name of a locality load balancer policy to be used. The value
	// should be one of the predefined ones as supported by localityLbPolicy,
	// although at the moment only ROUND_ROBIN is supported.
	// This field should only be populated when the customPolicy field is not
	// used.
	// Note that specifying the same policy more than once for a backend is
	// not a valid configuration and will be rejected.
	// The possible values are:
	// +kubebuilder:validation:Optional
	name?: null | string @go(Name,*string)
}

#SecuritySettingsInitParameters: {
	// ClientTlsPolicy is a resource that specifies how a client should authenticate
	// connections to backends of a service. This resource itself does not affect
	// configuration unless it is attached to a backend service resource.
	clientTlsPolicy?: null | string @go(ClientTLSPolicy,*string)

	// A list of alternate names to verify the subject identity in the certificate.
	// If specified, the client will verify that the server certificate's subject
	// alt name matches one of the specified values.
	subjectAltNames?: [...null | string] @go(SubjectAltNames,[]*string)
}

#SecuritySettingsObservation: {
	// ClientTlsPolicy is a resource that specifies how a client should authenticate
	// connections to backends of a service. This resource itself does not affect
	// configuration unless it is attached to a backend service resource.
	clientTlsPolicy?: null | string @go(ClientTLSPolicy,*string)

	// A list of alternate names to verify the subject identity in the certificate.
	// If specified, the client will verify that the server certificate's subject
	// alt name matches one of the specified values.
	subjectAltNames?: [...null | string] @go(SubjectAltNames,[]*string)
}

#SecuritySettingsParameters: {
	// ClientTlsPolicy is a resource that specifies how a client should authenticate
	// connections to backends of a service. This resource itself does not affect
	// configuration unless it is attached to a backend service resource.
	// +kubebuilder:validation:Optional
	clientTlsPolicy?: null | string @go(ClientTLSPolicy,*string)

	// A list of alternate names to verify the subject identity in the certificate.
	// If specified, the client will verify that the server certificate's subject
	// alt name matches one of the specified values.
	// +kubebuilder:validation:Optional
	subjectAltNames: [...null | string] @go(SubjectAltNames,[]*string)
}

#TTLInitParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#TTLObservation: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	seconds?: null | float64 @go(Seconds,*float64)
}

#TTLParameters: {
	// Span of time that's a fraction of a second at nanosecond
	// resolution. Durations less than one second are represented
	// with a 0 seconds field and a positive nanos field. Must
	// be from 0 to 999,999,999 inclusive.
	// +kubebuilder:validation:Optional
	nanos?: null | float64 @go(Nanos,*float64)

	// Span of time at a resolution of a second.
	// Must be from 0 to 315,576,000,000 inclusive.
	// +kubebuilder:validation:Optional
	seconds?: null | float64 @go(Seconds,*float64)
}

// BackendServiceSpec defines the desired state of BackendService
#BackendServiceSpec: {
	v1.#ResourceSpec
	forProvider: #BackendServiceParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #BackendServiceInitParameters @go(InitProvider)
}

// BackendServiceStatus defines the observed state of BackendService.
#BackendServiceStatus: {
	v1.#ResourceStatus
	atProvider?: #BackendServiceObservation @go(AtProvider)
}

// BackendService is the Schema for the BackendServices API. A Backend Service defines a group of virtual machines that will serve traffic for load balancing.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
#BackendService: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta    @go(ObjectMeta)
	spec:      #BackendServiceSpec   @go(Spec)
	status?:   #BackendServiceStatus @go(Status)
}

// BackendServiceList contains a list of BackendServices
#BackendServiceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#BackendService] @go(Items,[]BackendService)
}
