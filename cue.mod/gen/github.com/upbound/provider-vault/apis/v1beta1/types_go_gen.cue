// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-vault/apis/v1beta1

package v1beta1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// A ProviderConfigSpec defines the desired state of a ProviderConfig.
#ProviderConfigSpec: {
	// Required origin URL of the Vault server.
	// This is a URL with a scheme, a hostname
	// and a port but with no path.
	address: string @go(Address)

	// If true the environment variable
	// VAULT_ADDR in the Terraform process environment
	// will be set to the value of the address argument
	// from this provider. By default, this is false.
	// +optional
	add_address_to_env?: bool @go(AddAddressToEnv)

	// Set this to true to disable verification
	// of the Vault server's TLS certificate. This is
	// strongly discouraged except in prototype or
	// development environments, since it exposes the
	// possibility that Terraform can be tricked into
	// writing secrets to a server controlled by an intruder.
	// +optional
	skip_tls_verify?: bool @go(SkipTLSVerify)

	// Name to use as the SNI host when connecting
	// via TLS.
	// +optional
	tls_server_name?: string @go(TLSServerName)

	// Set this to true to disable creation of an
	// intermediate ephemeral Vault token for Terraform to use.
	// Enabling this is strongly discouraged since it increases
	// the potential for a renewable Vault token being exposed
	// in clear text. Only change this setting when the provided
	// token cannot be permitted to create child tokens and there
	// is no risk of exposure from the output of Terraform.
	// +optional
	skip_child_token?: bool @go(SkipChildToken)

	// Used as the duration for the intermediate Vault
	// token Terraform issues itself, which in turn limits the
	// duration of secret leases issued by Vault. Defaults to
	// 20 minutes.
	// +optional
	max_lease_ttl_seconds?: int @go(MaxLeaseTTLSeconds)

	// Used as the maximum number of retries when a
	// 5xx error code is encountered. Defaults to 2 retries.
	// +optional
	max_retries?: int @go(MaxRetries)

	// Maximum number of retries for Client Controlled
	// Consistency related operations. Defaults to 10 retries.
	// +optional
	max_retries_ccc?: int @go(MaxRetriesCcc)

	// Set the namespace to use.
	// +optional
	namespace?: string @go(Namespace)

	// Skip the dynamic fetching of the Vault server
	// version. Set to true when the /sys/seal-status API
	// endpoint is not available.
	// +optional
	skip_get_vault_version?: bool @go(SkipGetVaultVersion)

	// Override the target Vault server semantic
	// version. Normally the version is dynamically set
	// from the /sys/seal-status API endpoint. In the case
	// where this endpoint is not available an override can
	// be specified here.
	// +optional
	vault_version_override?: string @go(VaultVersionOverride)

	// A configuration block, described below,
	// that provides headers to be sent along with all
	// requests to the Vault server. This block can be
	// specified multiple times.
	// +optional
	headers?: #ProviderHeaders @go(Headers)

	// Credentials required to authenticate to this provider.
	// There are many options to authenticate. They include
	// - token - (Optional) Vault token that will be used
	// by Terraform to authenticate. May be set via the
	// VAULT_TOKEN environment variable. If none is otherwise
	// supplied, Terraform will attempt to read it from
	// ~/.vault-token (where the vault command stores its
	// current token). Terraform will issue itself a new token
	// that is a child of the one given, with a short TTL to
	// limit the exposure of any requested secrets, unless
	// skip_child_token is set to true (see below). Note
	// that the given token must have the update capability
	// on the auth/token/create path in Vault in order to create
	// child tokens. A token is required for the provider. A
	// token can explicitly set via token argument, alternatively
	// a token can be dynamically set via an auth_login* block.
	// +optional
	credentials?: #ProviderCredentials @go(Credentials)
}

// ProviderHeaders optional.
#ProviderHeaders: {
	// Required header name
	name: string @go(Name)

	// Required header value
	value: string @go(Value)
}

// ProviderCredentials required to authenticate.
#ProviderCredentials: {
	// Source of the provider credentials.
	// +kubebuilder:validation:Enum=None;Secret;InjectedIdentity;Environment;Filesystem
	source: xpv1.#CredentialsSource @go(Source)

	xpv1.#CommonCredentialSelectors
}

// A ProviderConfigStatus reflects the observed state of a ProviderConfig.
#ProviderConfigStatus: {
	xpv1.#ProviderConfigStatus
}

// A ProviderConfig configures a Vault provider.
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:printcolumn:name="SECRET-NAME",type="string",JSONPath=".spec.credentials.secretRef.name",priority=1
// +kubebuilder:resource:scope=Cluster
// +kubebuilder:resource:scope=Cluster,categories={crossplane,provider,vault}
#ProviderConfig: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta    @go(ObjectMeta)
	spec:      #ProviderConfigSpec   @go(Spec)
	status?:   #ProviderConfigStatus @go(Status)
}

// ProviderConfigList contains a list of ProviderConfig.
#ProviderConfigList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ProviderConfig] @go(Items,[]ProviderConfig)
}

// A ProviderConfigUsage indicates that a resource is using a ProviderConfig.
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:printcolumn:name="CONFIG-NAME",type="string",JSONPath=".providerConfigRef.name"
// +kubebuilder:printcolumn:name="RESOURCE-KIND",type="string",JSONPath=".resourceRef.kind"
// +kubebuilder:printcolumn:name="RESOURCE-NAME",type="string",JSONPath=".resourceRef.name"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,provider,vault}
#ProviderConfigUsage: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	xpv1.#ProviderConfigUsage
}

// ProviderConfigUsageList contains a list of ProviderConfigUsage
#ProviderConfigUsageList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ProviderConfigUsage] @go(Items,[]ProviderConfigUsage)
}
