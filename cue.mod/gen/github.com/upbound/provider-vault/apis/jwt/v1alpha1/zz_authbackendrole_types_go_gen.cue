// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/upbound/provider-vault/apis/jwt/v1alpha1

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#AuthBackendRoleInitParameters: {
	// The list of allowed values for redirect_uri during OIDC logins.
	// Required for OIDC roles
	// The list of allowed values for redirect_uri during OIDC logins.
	allowedRedirectUris?: [...null | string] @go(AllowedRedirectUris,[]*string)

	// The unique name of the auth backend to configure.
	// Defaults to jwt.
	// Unique name of the auth backend to configure.
	backend?: null | string @go(Backend,*string)

	// (For "jwt" roles, at least one of bound_audiences, bound_subject, bound_claims
	// or token_bound_cidrs is required. Optional for "oidc" roles.) List of aud claims to match against.
	// Any match is sufficient.
	// List of aud claims to match against. Any match is sufficient.
	boundAudiences?: [...null | string] @go(BoundAudiences,[]*string)

	// If set, a map of claims to values to match against.
	// A claim's value must be a string, which may contain one value or multiple
	// comma-separated values, e.g. "red" or "red,green,blue".
	// Map of claims/values to match against. The expected value may be a single string or a comma-separated string list.
	boundClaims?: {[string]: null | string} @go(BoundClaims,map[string]*string)

	// How to interpret values in the claims/values
	// map (bound_claims): can be either string (exact match) or glob (wildcard
	// match). Requires Vault 1.4.0 or above.
	// How to interpret values in the claims/values map: can be either "string" (exact match) or "glob" (wildcard match).
	boundClaimsType?: null | string @go(BoundClaimsType,*string)

	// If set, requires that the sub claim matches
	// this value.
	// If set, requires that the sub claim matches this value.
	boundSubject?: null | string @go(BoundSubject,*string)

	// If set, a map of claims (keys) to be copied
	// to specified metadata fields (values).
	// Map of claims (keys) to be copied to specified metadata fields (values).
	claimMappings?: {[string]: null | string} @go(ClaimMappings,map[string]*string)

	// The amount of leeway to add to all claims to account for clock skew, in
	// seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	clockSkewLeeway?: null | float64 @go(ClockSkewLeeway,*float64)

	// Disable bound claim value parsing. Useful when values contain commas.
	disableBoundClaimsParsing?: null | bool @go(DisableBoundClaimsParsing,*bool)

	// The amount of leeway to add to expiration (exp) claims to account for
	// clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	expirationLeeway?: null | float64 @go(ExpirationLeeway,*float64)

	// The claim to use to uniquely identify
	// the set of groups to which the user belongs; this will be used as the names
	// for the Identity group aliases created due to a successful login. The claim
	// value must be a list of strings.
	// The claim to use to uniquely identify the set of groups to which the user belongs; this will be used as the names for the Identity group aliases created due to a successful login. The claim value must be a list of strings.
	groupsClaim?: null | string @go(GroupsClaim,*string)

	// Specifies the allowable elapsed time in seconds since the last time
	// the user was actively authenticated with the OIDC provider.
	// Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.
	maxAge?: null | float64 @go(MaxAge,*float64)

	// The namespace to provision the resource in.
	// The value should not contain leading or trailing forward slashes.
	// The namespace is always relative to the provider's configured namespace.
	// Available only for Vault Enterprise.
	// Target namespace. (requires Enterprise)
	namespace?: null | string @go(Namespace,*string)

	// The amount of leeway to add to not before (nbf) claims to account for
	// clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	notBeforeLeeway?: null | float64 @go(NotBeforeLeeway,*float64)

	// If set, a list of OIDC scopes to be used with an OIDC role.
	// The standard scope "openid" is automatically included and need not be specified.
	// List of OIDC scopes to be used with an OIDC role. The standard scope "openid" is automatically included and need not be specified.
	oidcScopes?: [...null | string] @go(OidcScopes,[]*string)

	// The name of the role.
	// Name of the role.
	roleName?: null | string @go(RoleName,*string)

	// Type of role, either "oidc" (default) or "jwt".
	// Type of role, either "oidc" (default) or "jwt"
	roleType?: null | string @go(RoleType,*string)

	// List of CIDR blocks; if set, specifies blocks of IP
	// addresses which can authenticate successfully, and ties the resulting token to these blocks
	// as well.
	// Specifies the blocks of IP addresses which are allowed to use the generated token
	tokenBoundCidrs?: [...null | string] @go(TokenBoundCidrs,[]*string)

	// If set, will encode an
	// explicit max TTL
	// onto the token in number of seconds. This is a hard cap even if token_ttl and
	// token_max_ttl would otherwise allow a renewal.
	// Generated Token's Explicit Maximum TTL in seconds
	tokenExplicitMaxTtl?: null | float64 @go(TokenExplicitMaxTTL,*float64)

	// The maximum lifetime for generated tokens in number of seconds.
	// Its current value will be referenced at renewal time.
	// The maximum lifetime of the generated token
	tokenMaxTtl?: null | float64 @go(TokenMaxTTL,*float64)

	// If set, the default policy will not be set on
	// generated tokens; otherwise it will be added to the policies set in token_policies.
	// If true, the 'default' policy will not automatically be added to generated tokens
	tokenNoDefaultPolicy?: null | bool @go(TokenNoDefaultPolicy,*bool)

	// The maximum number
	// of times a generated token may be used (within its lifetime); 0 means unlimited.
	// The maximum number of times a token may be used, a value of zero means unlimited
	tokenNumUses?: null | float64 @go(TokenNumUses,*float64)

	// If set, indicates that the
	// token generated using this role should never expire. The token should be renewed within the
	// duration specified by this value. At each renewal, the token's TTL will be set to the
	// value of this field. Specified in seconds.
	// Generated Token's Period
	tokenPeriod?: null | float64 @go(TokenPeriod,*float64)

	// List of policies to encode onto generated tokens. Depending
	// on the auth method, this list may be supplemented by user/group/other values.
	// Generated Token's Policies
	tokenPolicies?: [...null | string] @go(TokenPolicies,[]*string)

	// The incremental lifetime for generated tokens in number of seconds.
	// Its current value will be referenced at renewal time.
	// The initial ttl of the token to generate in seconds
	tokenTtl?: null | float64 @go(TokenTTL,*float64)

	// The type of token that should be generated. Can be service,
	// batch, or default to use the mount's tuned default (which unless changed will be
	// service tokens). For token store roles, there are two additional possibilities:
	// default-service and default-batch which specify the type to return unless the client
	// requests a different type at generation time.
	// The type of token to generate, service or batch
	tokenType?: null | string @go(TokenType,*string)

	// The claim to use to uniquely identify
	// the user; this will be used as the name for the Identity entity alias created
	// due to a successful login.
	// The claim to use to uniquely identify the user; this will be used as the name for the Identity entity alias created due to a successful login.
	userClaim?: null | string @go(UserClaim,*string)

	// Specifies if the user_claim value uses
	// JSON pointer
	// syntax for referencing claims. By default, the user_claim value will not use JSON pointer.
	// Requires Vault 1.11+.
	// Specifies if the user_claim value uses JSON pointer syntax for referencing claims. By default, the user_claim value will not use JSON pointer.
	userClaimJsonPointer?: null | bool @go(UserClaimJSONPointer,*bool)

	// Log received OIDC tokens and claims when debug-level
	// logging is active. Not recommended in production since sensitive information may be present
	// in OIDC responses.
	// Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses.
	verboseOidcLogging?: null | bool @go(VerboseOidcLogging,*bool)
}

#AuthBackendRoleObservation: {
	// The list of allowed values for redirect_uri during OIDC logins.
	// Required for OIDC roles
	// The list of allowed values for redirect_uri during OIDC logins.
	allowedRedirectUris?: [...null | string] @go(AllowedRedirectUris,[]*string)

	// The unique name of the auth backend to configure.
	// Defaults to jwt.
	// Unique name of the auth backend to configure.
	backend?: null | string @go(Backend,*string)

	// (For "jwt" roles, at least one of bound_audiences, bound_subject, bound_claims
	// or token_bound_cidrs is required. Optional for "oidc" roles.) List of aud claims to match against.
	// Any match is sufficient.
	// List of aud claims to match against. Any match is sufficient.
	boundAudiences?: [...null | string] @go(BoundAudiences,[]*string)

	// If set, a map of claims to values to match against.
	// A claim's value must be a string, which may contain one value or multiple
	// comma-separated values, e.g. "red" or "red,green,blue".
	// Map of claims/values to match against. The expected value may be a single string or a comma-separated string list.
	boundClaims?: {[string]: null | string} @go(BoundClaims,map[string]*string)

	// How to interpret values in the claims/values
	// map (bound_claims): can be either string (exact match) or glob (wildcard
	// match). Requires Vault 1.4.0 or above.
	// How to interpret values in the claims/values map: can be either "string" (exact match) or "glob" (wildcard match).
	boundClaimsType?: null | string @go(BoundClaimsType,*string)

	// If set, requires that the sub claim matches
	// this value.
	// If set, requires that the sub claim matches this value.
	boundSubject?: null | string @go(BoundSubject,*string)

	// If set, a map of claims (keys) to be copied
	// to specified metadata fields (values).
	// Map of claims (keys) to be copied to specified metadata fields (values).
	claimMappings?: {[string]: null | string} @go(ClaimMappings,map[string]*string)

	// The amount of leeway to add to all claims to account for clock skew, in
	// seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	clockSkewLeeway?: null | float64 @go(ClockSkewLeeway,*float64)

	// Disable bound claim value parsing. Useful when values contain commas.
	disableBoundClaimsParsing?: null | bool @go(DisableBoundClaimsParsing,*bool)

	// The amount of leeway to add to expiration (exp) claims to account for
	// clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	expirationLeeway?: null | float64 @go(ExpirationLeeway,*float64)

	// The claim to use to uniquely identify
	// the set of groups to which the user belongs; this will be used as the names
	// for the Identity group aliases created due to a successful login. The claim
	// value must be a list of strings.
	// The claim to use to uniquely identify the set of groups to which the user belongs; this will be used as the names for the Identity group aliases created due to a successful login. The claim value must be a list of strings.
	groupsClaim?: null | string @go(GroupsClaim,*string)
	id?:          null | string @go(ID,*string)

	// Specifies the allowable elapsed time in seconds since the last time
	// the user was actively authenticated with the OIDC provider.
	// Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.
	maxAge?: null | float64 @go(MaxAge,*float64)

	// The namespace to provision the resource in.
	// The value should not contain leading or trailing forward slashes.
	// The namespace is always relative to the provider's configured namespace.
	// Available only for Vault Enterprise.
	// Target namespace. (requires Enterprise)
	namespace?: null | string @go(Namespace,*string)

	// The amount of leeway to add to not before (nbf) claims to account for
	// clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	notBeforeLeeway?: null | float64 @go(NotBeforeLeeway,*float64)

	// If set, a list of OIDC scopes to be used with an OIDC role.
	// The standard scope "openid" is automatically included and need not be specified.
	// List of OIDC scopes to be used with an OIDC role. The standard scope "openid" is automatically included and need not be specified.
	oidcScopes?: [...null | string] @go(OidcScopes,[]*string)

	// The name of the role.
	// Name of the role.
	roleName?: null | string @go(RoleName,*string)

	// Type of role, either "oidc" (default) or "jwt".
	// Type of role, either "oidc" (default) or "jwt"
	roleType?: null | string @go(RoleType,*string)

	// List of CIDR blocks; if set, specifies blocks of IP
	// addresses which can authenticate successfully, and ties the resulting token to these blocks
	// as well.
	// Specifies the blocks of IP addresses which are allowed to use the generated token
	tokenBoundCidrs?: [...null | string] @go(TokenBoundCidrs,[]*string)

	// If set, will encode an
	// explicit max TTL
	// onto the token in number of seconds. This is a hard cap even if token_ttl and
	// token_max_ttl would otherwise allow a renewal.
	// Generated Token's Explicit Maximum TTL in seconds
	tokenExplicitMaxTtl?: null | float64 @go(TokenExplicitMaxTTL,*float64)

	// The maximum lifetime for generated tokens in number of seconds.
	// Its current value will be referenced at renewal time.
	// The maximum lifetime of the generated token
	tokenMaxTtl?: null | float64 @go(TokenMaxTTL,*float64)

	// If set, the default policy will not be set on
	// generated tokens; otherwise it will be added to the policies set in token_policies.
	// If true, the 'default' policy will not automatically be added to generated tokens
	tokenNoDefaultPolicy?: null | bool @go(TokenNoDefaultPolicy,*bool)

	// The maximum number
	// of times a generated token may be used (within its lifetime); 0 means unlimited.
	// The maximum number of times a token may be used, a value of zero means unlimited
	tokenNumUses?: null | float64 @go(TokenNumUses,*float64)

	// If set, indicates that the
	// token generated using this role should never expire. The token should be renewed within the
	// duration specified by this value. At each renewal, the token's TTL will be set to the
	// value of this field. Specified in seconds.
	// Generated Token's Period
	tokenPeriod?: null | float64 @go(TokenPeriod,*float64)

	// List of policies to encode onto generated tokens. Depending
	// on the auth method, this list may be supplemented by user/group/other values.
	// Generated Token's Policies
	tokenPolicies?: [...null | string] @go(TokenPolicies,[]*string)

	// The incremental lifetime for generated tokens in number of seconds.
	// Its current value will be referenced at renewal time.
	// The initial ttl of the token to generate in seconds
	tokenTtl?: null | float64 @go(TokenTTL,*float64)

	// The type of token that should be generated. Can be service,
	// batch, or default to use the mount's tuned default (which unless changed will be
	// service tokens). For token store roles, there are two additional possibilities:
	// default-service and default-batch which specify the type to return unless the client
	// requests a different type at generation time.
	// The type of token to generate, service or batch
	tokenType?: null | string @go(TokenType,*string)

	// The claim to use to uniquely identify
	// the user; this will be used as the name for the Identity entity alias created
	// due to a successful login.
	// The claim to use to uniquely identify the user; this will be used as the name for the Identity entity alias created due to a successful login.
	userClaim?: null | string @go(UserClaim,*string)

	// Specifies if the user_claim value uses
	// JSON pointer
	// syntax for referencing claims. By default, the user_claim value will not use JSON pointer.
	// Requires Vault 1.11+.
	// Specifies if the user_claim value uses JSON pointer syntax for referencing claims. By default, the user_claim value will not use JSON pointer.
	userClaimJsonPointer?: null | bool @go(UserClaimJSONPointer,*bool)

	// Log received OIDC tokens and claims when debug-level
	// logging is active. Not recommended in production since sensitive information may be present
	// in OIDC responses.
	// Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses.
	verboseOidcLogging?: null | bool @go(VerboseOidcLogging,*bool)
}

#AuthBackendRoleParameters: {
	// The list of allowed values for redirect_uri during OIDC logins.
	// Required for OIDC roles
	// The list of allowed values for redirect_uri during OIDC logins.
	// +kubebuilder:validation:Optional
	allowedRedirectUris?: [...null | string] @go(AllowedRedirectUris,[]*string)

	// The unique name of the auth backend to configure.
	// Defaults to jwt.
	// Unique name of the auth backend to configure.
	// +kubebuilder:validation:Optional
	backend?: null | string @go(Backend,*string)

	// (For "jwt" roles, at least one of bound_audiences, bound_subject, bound_claims
	// or token_bound_cidrs is required. Optional for "oidc" roles.) List of aud claims to match against.
	// Any match is sufficient.
	// List of aud claims to match against. Any match is sufficient.
	// +kubebuilder:validation:Optional
	boundAudiences?: [...null | string] @go(BoundAudiences,[]*string)

	// If set, a map of claims to values to match against.
	// A claim's value must be a string, which may contain one value or multiple
	// comma-separated values, e.g. "red" or "red,green,blue".
	// Map of claims/values to match against. The expected value may be a single string or a comma-separated string list.
	// +kubebuilder:validation:Optional
	boundClaims?: {[string]: null | string} @go(BoundClaims,map[string]*string)

	// How to interpret values in the claims/values
	// map (bound_claims): can be either string (exact match) or glob (wildcard
	// match). Requires Vault 1.4.0 or above.
	// How to interpret values in the claims/values map: can be either "string" (exact match) or "glob" (wildcard match).
	// +kubebuilder:validation:Optional
	boundClaimsType?: null | string @go(BoundClaimsType,*string)

	// If set, requires that the sub claim matches
	// this value.
	// If set, requires that the sub claim matches this value.
	// +kubebuilder:validation:Optional
	boundSubject?: null | string @go(BoundSubject,*string)

	// If set, a map of claims (keys) to be copied
	// to specified metadata fields (values).
	// Map of claims (keys) to be copied to specified metadata fields (values).
	// +kubebuilder:validation:Optional
	claimMappings?: {[string]: null | string} @go(ClaimMappings,map[string]*string)

	// The amount of leeway to add to all claims to account for clock skew, in
	// seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	// +kubebuilder:validation:Optional
	clockSkewLeeway?: null | float64 @go(ClockSkewLeeway,*float64)

	// Disable bound claim value parsing. Useful when values contain commas.
	// +kubebuilder:validation:Optional
	disableBoundClaimsParsing?: null | bool @go(DisableBoundClaimsParsing,*bool)

	// The amount of leeway to add to expiration (exp) claims to account for
	// clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	// +kubebuilder:validation:Optional
	expirationLeeway?: null | float64 @go(ExpirationLeeway,*float64)

	// The claim to use to uniquely identify
	// the set of groups to which the user belongs; this will be used as the names
	// for the Identity group aliases created due to a successful login. The claim
	// value must be a list of strings.
	// The claim to use to uniquely identify the set of groups to which the user belongs; this will be used as the names for the Identity group aliases created due to a successful login. The claim value must be a list of strings.
	// +kubebuilder:validation:Optional
	groupsClaim?: null | string @go(GroupsClaim,*string)

	// Specifies the allowable elapsed time in seconds since the last time
	// the user was actively authenticated with the OIDC provider.
	// Specifies the allowable elapsed time in seconds since the last time the user was actively authenticated.
	// +kubebuilder:validation:Optional
	maxAge?: null | float64 @go(MaxAge,*float64)

	// The namespace to provision the resource in.
	// The value should not contain leading or trailing forward slashes.
	// The namespace is always relative to the provider's configured namespace.
	// Available only for Vault Enterprise.
	// Target namespace. (requires Enterprise)
	// +kubebuilder:validation:Optional
	namespace?: null | string @go(Namespace,*string)

	// The amount of leeway to add to not before (nbf) claims to account for
	// clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1.
	// Only applicable with "jwt" roles.
	// The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
	// +kubebuilder:validation:Optional
	notBeforeLeeway?: null | float64 @go(NotBeforeLeeway,*float64)

	// If set, a list of OIDC scopes to be used with an OIDC role.
	// The standard scope "openid" is automatically included and need not be specified.
	// List of OIDC scopes to be used with an OIDC role. The standard scope "openid" is automatically included and need not be specified.
	// +kubebuilder:validation:Optional
	oidcScopes?: [...null | string] @go(OidcScopes,[]*string)

	// The name of the role.
	// Name of the role.
	// +kubebuilder:validation:Optional
	roleName?: null | string @go(RoleName,*string)

	// Type of role, either "oidc" (default) or "jwt".
	// Type of role, either "oidc" (default) or "jwt"
	// +kubebuilder:validation:Optional
	roleType?: null | string @go(RoleType,*string)

	// List of CIDR blocks; if set, specifies blocks of IP
	// addresses which can authenticate successfully, and ties the resulting token to these blocks
	// as well.
	// Specifies the blocks of IP addresses which are allowed to use the generated token
	// +kubebuilder:validation:Optional
	tokenBoundCidrs?: [...null | string] @go(TokenBoundCidrs,[]*string)

	// If set, will encode an
	// explicit max TTL
	// onto the token in number of seconds. This is a hard cap even if token_ttl and
	// token_max_ttl would otherwise allow a renewal.
	// Generated Token's Explicit Maximum TTL in seconds
	// +kubebuilder:validation:Optional
	tokenExplicitMaxTtl?: null | float64 @go(TokenExplicitMaxTTL,*float64)

	// The maximum lifetime for generated tokens in number of seconds.
	// Its current value will be referenced at renewal time.
	// The maximum lifetime of the generated token
	// +kubebuilder:validation:Optional
	tokenMaxTtl?: null | float64 @go(TokenMaxTTL,*float64)

	// If set, the default policy will not be set on
	// generated tokens; otherwise it will be added to the policies set in token_policies.
	// If true, the 'default' policy will not automatically be added to generated tokens
	// +kubebuilder:validation:Optional
	tokenNoDefaultPolicy?: null | bool @go(TokenNoDefaultPolicy,*bool)

	// The maximum number
	// of times a generated token may be used (within its lifetime); 0 means unlimited.
	// The maximum number of times a token may be used, a value of zero means unlimited
	// +kubebuilder:validation:Optional
	tokenNumUses?: null | float64 @go(TokenNumUses,*float64)

	// If set, indicates that the
	// token generated using this role should never expire. The token should be renewed within the
	// duration specified by this value. At each renewal, the token's TTL will be set to the
	// value of this field. Specified in seconds.
	// Generated Token's Period
	// +kubebuilder:validation:Optional
	tokenPeriod?: null | float64 @go(TokenPeriod,*float64)

	// List of policies to encode onto generated tokens. Depending
	// on the auth method, this list may be supplemented by user/group/other values.
	// Generated Token's Policies
	// +kubebuilder:validation:Optional
	tokenPolicies?: [...null | string] @go(TokenPolicies,[]*string)

	// The incremental lifetime for generated tokens in number of seconds.
	// Its current value will be referenced at renewal time.
	// The initial ttl of the token to generate in seconds
	// +kubebuilder:validation:Optional
	tokenTtl?: null | float64 @go(TokenTTL,*float64)

	// The type of token that should be generated. Can be service,
	// batch, or default to use the mount's tuned default (which unless changed will be
	// service tokens). For token store roles, there are two additional possibilities:
	// default-service and default-batch which specify the type to return unless the client
	// requests a different type at generation time.
	// The type of token to generate, service or batch
	// +kubebuilder:validation:Optional
	tokenType?: null | string @go(TokenType,*string)

	// The claim to use to uniquely identify
	// the user; this will be used as the name for the Identity entity alias created
	// due to a successful login.
	// The claim to use to uniquely identify the user; this will be used as the name for the Identity entity alias created due to a successful login.
	// +kubebuilder:validation:Optional
	userClaim?: null | string @go(UserClaim,*string)

	// Specifies if the user_claim value uses
	// JSON pointer
	// syntax for referencing claims. By default, the user_claim value will not use JSON pointer.
	// Requires Vault 1.11+.
	// Specifies if the user_claim value uses JSON pointer syntax for referencing claims. By default, the user_claim value will not use JSON pointer.
	// +kubebuilder:validation:Optional
	userClaimJsonPointer?: null | bool @go(UserClaimJSONPointer,*bool)

	// Log received OIDC tokens and claims when debug-level
	// logging is active. Not recommended in production since sensitive information may be present
	// in OIDC responses.
	// Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses.
	// +kubebuilder:validation:Optional
	verboseOidcLogging?: null | bool @go(VerboseOidcLogging,*bool)
}

// AuthBackendRoleSpec defines the desired state of AuthBackendRole
#AuthBackendRoleSpec: {
	v1.#ResourceSpec
	forProvider: #AuthBackendRoleParameters @go(ForProvider)

	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	initProvider?: #AuthBackendRoleInitParameters @go(InitProvider)
}

// AuthBackendRoleStatus defines the observed state of AuthBackendRole.
#AuthBackendRoleStatus: {
	v1.#ResourceStatus
	atProvider?: #AuthBackendRoleObservation @go(AtProvider)
}

// AuthBackendRole is the Schema for the AuthBackendRoles API. Manages JWT/OIDC auth backend roles in Vault.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,vault}
#AuthBackendRole: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.roleName) || has(self.initProvider.roleName)",message="roleName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.userClaim) || has(self.initProvider.userClaim)",message="userClaim is a required parameter"
	spec:    #AuthBackendRoleSpec   @go(Spec)
	status?: #AuthBackendRoleStatus @go(Status)
}

// AuthBackendRoleList contains a list of AuthBackendRoles
#AuthBackendRoleList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#AuthBackendRole] @go(Items,[]AuthBackendRole)
}
