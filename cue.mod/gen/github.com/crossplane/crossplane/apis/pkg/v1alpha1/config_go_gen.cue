// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/crossplane/crossplane/apis/pkg/v1alpha1

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ControllerConfigSpec specifies the configuration for a packaged controller.
// Values provided will override package manager defaults. Labels and
// annotations are passed to both the controller Deployment and ServiceAccount.
#ControllerConfigSpec: {
	// Metadata that will be added to the provider Pod.
	// +optional
	metadata?: null | #PodObjectMeta @go(Metadata,*PodObjectMeta)

	// Number of desired pods. This is a pointer to distinguish between explicit
	// zero and not specified. Defaults to 1.
	// Note: If more than 1 replica is set and leader election is not enabled then
	// controllers could conflict. Environment variable "LEADER_ELECTION" can be
	// used to enable leader election process.
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// Docker image name.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// This field is optional to allow higher level config management to default or override
	// container images in workload controllers like Deployments and StatefulSets.
	// +optional
	image?: null | string @go(Image,*string)

	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// If specified, a ServiceAccount named this ServiceAccountName will be used for
	// the spec.serviceAccountName field in Pods to be created and for the subjects.name field
	// in a ClusterRoleBinding to be created.
	// If there is no ServiceAccount named this ServiceAccountName, a new ServiceAccount
	// will be created.
	// If there is a pre-existing ServiceAccount named this ServiceAccountName, the ServiceAccount
	// will be used. The annotations in the ControllerConfig will be copied to the ServiceAccount
	// and pre-existing annotations will be kept.
	// Regardless of whether there is a ServiceAccount created by Crossplane or is in place already,
	// the ServiceAccount will be deleted once the Provider and ControllerConfig are deleted.
	// +optional
	serviceAccountName?: null | string @go(ServiceAccountName,*string)

	// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
	// the scheduler simply schedules this pod onto that node, assuming that it fits resource
	// requirements.
	// +optional
	nodeName?: null | string @go(NodeName,*string)

	// PodSecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	podSecurityContext?: null | corev1.#PodSecurityContext @go(PodSecurityContext,*corev1.PodSecurityContext)

	// SecurityContext holds container-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	securityContext?: null | corev1.#SecurityContext @go(SecurityContext,*corev1.SecurityContext)

	// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
	// If specified, these secrets will be passed to individual puller implementations for them to use. For example,
	// in the case of docker, only DockerConfig type secrets are honored.
	// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
	// Setting ImagePullSecrets will replace any secrets that have been
	// propagated to a controller Deployment, typically via packagePullSecrets.
	// +optional
	imagePullSecrets?: [...corev1.#LocalObjectReference] @go(ImagePullSecrets,[]corev1.LocalObjectReference)

	// Image pull policy.
	// One of Always, Never, IfNotPresent.
	// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	// +optional
	imagePullPolicy?: null | corev1.#PullPolicy @go(ImagePullPolicy,*corev1.PullPolicy)

	// If specified, the pod's scheduling constraints
	// +optional
	affinity?: null | corev1.#Affinity @go(Affinity,*corev1.Affinity)

	// If specified, the pod's tolerations.
	// +optional
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)

	// If specified, indicates the pod's priority. "system-node-critical" and
	// "system-cluster-critical" are two special keywords which indicate the
	// highest priorities with the former being the highest priority. Any other
	// name must be defined by creating a PriorityClass object with that name.
	// If not specified, the pod priority will be default or zero if there is no
	// default.
	// +optional
	priorityClassName?: null | string @go(PriorityClassName,*string)

	// RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
	// to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
	// If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
	// empty definition that uses the default runtime handler.
	// More info: https://git.k8s.io/enhancements/keps/sig-node/runtime-class.md
	// This is a beta feature as of Kubernetes v1.14.
	// +optional
	runtimeClassName?: null | string @go(RuntimeClassName,*string)

	// Compute Resources required by this container.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	// +optional
	resources?: null | corev1.#ResourceRequirements @go(ResourceRequirements,*corev1.ResourceRequirements)

	// Arguments to the entrypoint.
	// The docker image's CMD is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
	// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
	// regardless of whether the variable exists or not.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	args?: [...string] @go(Args,[]string)

	// List of sources to populate environment variables in the container.
	// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
	// will be reported as an event when the container is starting. When a key exists in multiple
	// sources, the value associated with the last source will take precedence.
	// Values defined by an Env with a duplicate key will take precedence.
	// Cannot be updated.
	// +optional
	envFrom?: [...corev1.#EnvFromSource] @go(EnvFrom,[]corev1.EnvFromSource)

	// List of environment variables to set in the container.
	// Cannot be updated.
	// +optional
	env?: [...corev1.#EnvVar] @go(Env,[]corev1.EnvVar)

	// List of container ports to expose on the container
	// +optional
	ports?: [...corev1.#ContainerPort] @go(Ports,[]corev1.ContainerPort)

	// List of volumes that can be mounted by containers belonging to the pod.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes
	// +optional
	volumes?: [...corev1.#Volume] @go(Volumes,[]corev1.Volume)

	// List of VolumeMounts to mount into the container's filesystem.
	// Cannot be updated.
	// +optional
	volumeMounts?: [...corev1.#VolumeMount] @go(VolumeMounts,[]corev1.VolumeMount)
}

// PodObjectMeta is metadata that is added to the Pods in a provider's
// Deployment.
#PodObjectMeta: {
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Map of string keys and values that can be used to organize and
	// categorize (scope and select) objects. This will only affect
	// labels on the pod, not the pod selector. Labels will be merged
	// with internal labels used by crossplane, and labels with a
	// crossplane.io key might be overwritten.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)
}

// ControllerConfig is the CRD type for a packaged controller configuration.
// Deprecated: This API is replaced by DeploymentRuntimeConfig, and is scheduled
// to be removed in a future release. See the design doc for more details:
// https://github.com/crossplane/crossplane/blob/11bbe13ea3604928cc4e24e8d0d18f3f5f7e847c/design/one-pager-package-runtime-config.md
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster
// +kubebuilder:deprecatedversion:warning="ControllerConfig.pkg.crossplane.io/v1alpha1 is deprecated. Use DeploymentRuntimeConfig from pkg.crossplane.io/v1beta1 instead."
#ControllerConfig: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta    @go(ObjectMeta)
	spec?:     #ControllerConfigSpec @go(Spec)
}

// ControllerConfigList contains a list of ControllerConfig.
#ControllerConfigList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ControllerConfig] @go(Items,[]ControllerConfig)
}
