// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/external-secrets/external-secrets/apis/externalsecrets/v1alpha1

package v1alpha1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// SecretStoreSpec defines the desired state of SecretStore.
#SecretStoreSpec: {
	// Used to select the correct ESO controller (think: ingress.ingressClassName)
	// The ESO controller is instantiated with a specific controller name and filters ES based on this property
	// +optional
	controller?: string @go(Controller)

	// Used to configure the provider. Only one provider may be set
	provider?: null | #SecretStoreProvider @go(Provider,*SecretStoreProvider)

	// Used to configure http retries if failed
	// +optional
	retrySettings?: null | #SecretStoreRetrySettings @go(RetrySettings,*SecretStoreRetrySettings)
}

// SecretStoreProvider contains the provider-specific configration.
// +kubebuilder:validation:MinProperties=1
// +kubebuilder:validation:MaxProperties=1
#SecretStoreProvider: {
	// AWS configures this store to sync secrets using AWS Secret Manager provider
	// +optional
	aws?: null | #AWSProvider @go(AWS,*AWSProvider)

	// AzureKV configures this store to sync secrets using Azure Key Vault provider
	// +optional
	azurekv?: null | #AzureKVProvider @go(AzureKV,*AzureKVProvider)

	// Akeyless configures this store to sync secrets using Akeyless Vault provider
	// +optional
	akeyless?: null | #AkeylessProvider @go(Akeyless,*AkeylessProvider)

	// Vault configures this store to sync secrets using Hashi provider
	// +optional
	vault?: null | #VaultProvider @go(Vault,*VaultProvider)

	// GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
	// +optional
	gcpsm?: null | #GCPSMProvider @go(GCPSM,*GCPSMProvider)

	// Oracle configures this store to sync secrets using Oracle Vault provider
	// +optional
	oracle?: null | #OracleProvider @go(Oracle,*OracleProvider)

	// IBM configures this store to sync secrets using IBM Cloud provider
	// +optional
	ibm?: null | #IBMProvider @go(IBM,*IBMProvider)

	// YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
	// +optional
	yandexlockbox?: null | #YandexLockboxProvider @go(YandexLockbox,*YandexLockboxProvider)

	// GitLab configures this store to sync secrets using GitLab Variables provider
	// +optional
	gitlab?: null | #GitlabProvider @go(Gitlab,*GitlabProvider)

	// Alibaba configures this store to sync secrets using Alibaba Cloud provider
	// +optional
	alibaba?: null | #AlibabaProvider @go(Alibaba,*AlibabaProvider)

	// Webhook configures this store to sync secrets using a generic templated webhook
	// +optional
	webhook?: null | #WebhookProvider @go(Webhook,*WebhookProvider)

	// Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
	// +optional
	kubernetes?: null | #KubernetesProvider @go(Kubernetes,*KubernetesProvider)

	// Fake configures a store with static key/value pairs
	// +optional
	fake?: null | #FakeProvider @go(Fake,*FakeProvider)
}

#SecretStoreRetrySettings: {
	maxRetries?:    null | int32  @go(MaxRetries,*int32)
	retryInterval?: null | string @go(RetryInterval,*string)
}

#SecretStoreConditionType: string // #enumSecretStoreConditionType

#enumSecretStoreConditionType:
	#SecretStoreReady

#SecretStoreReady:            #SecretStoreConditionType & "Ready"
#ReasonInvalidStore:          "InvalidStoreConfiguration"
#ReasonInvalidProviderConfig: "InvalidProviderConfig"
#ReasonValidationFailed:      "ValidationFailed"
#ReasonStoreValid:            "Valid"

#SecretStoreStatusCondition: {
	type:   #SecretStoreConditionType @go(Type)
	status: corev1.#ConditionStatus   @go(Status)

	// +optional
	reason?: string @go(Reason)

	// +optional
	message?: string @go(Message)

	// +optional
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)
}

// SecretStoreStatus defines the observed state of the SecretStore.
#SecretStoreStatus: {
	// +optional
	conditions?: [...#SecretStoreStatusCondition] @go(Conditions,[]SecretStoreStatusCondition)
}

// SecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:printcolumn:name="Status",type=string,JSONPath=`.status.conditions[?(@.type=="Ready")].reason`
// +kubebuilder:subresource:status
// +kubebuilder:deprecatedversion
// +kubebuilder:resource:scope=Namespaced,categories={externalsecrets},shortName=ss
#SecretStore: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #SecretStoreSpec   @go(Spec)
	status?:   #SecretStoreStatus @go(Status)
}

// SecretStoreList contains a list of SecretStore resources.
#SecretStoreList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#SecretStore] @go(Items,[]SecretStore)
}

// ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:printcolumn:name="Status",type=string,JSONPath=`.status.conditions[?(@.type=="Ready")].reason`
// +kubebuilder:deprecatedversion
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={externalsecrets},shortName=css
#ClusterSecretStore: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #SecretStoreSpec   @go(Spec)
	status?:   #SecretStoreStatus @go(Status)
}

// ClusterSecretStoreList contains a list of ClusterSecretStore resources.
#ClusterSecretStoreList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ClusterSecretStore] @go(Items,[]ClusterSecretStore)
}
