// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/VictoriaMetrics/operator/api/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/api/core/v1"
)

// VMServiceScrapeSpec defines the desired state of VMServiceScrape
#VMServiceScrapeSpec: {
	// DiscoveryRole - defines kubernetes_sd role for objects discovery.
	// by default, its endpoints.
	// can be changed to service or endpointslices.
	// note, that with service setting, you have to use port: "name"
	// and cannot use targetPort for endpoints.
	// +optional
	// +kubebuilder:validation:Enum=endpoints;service;endpointslices
	discoveryRole?: string @go(DiscoveryRole)

	// The label to use to retrieve the job name from.
	// +optional
	jobLabel?: string @go(JobLabel)

	// TargetLabels transfers labels on the Kubernetes Service onto the target.
	// +optional
	targetLabels?: [...string] @go(TargetLabels,[]string)

	// PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
	// +optional
	podTargetLabels?: [...string] @go(PodTargetLabels,[]string)

	// A list of endpoints allowed as part of this ServiceScrape.
	endpoints: [...#Endpoint] @go(Endpoints,[]Endpoint)

	// Selector to select Endpoints objects by corresponding Service labels.
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors=true
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.displayName="Service selector"
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.x-descriptors="urn:alm:descriptor:com.tectonic.ui:selector:"
	// +optional
	selector?: metav1.#LabelSelector @go(Selector)

	// Selector to select which namespaces the Endpoints objects are discovered from.
	// +optional
	namespaceSelector?: #NamespaceSelector @go(NamespaceSelector)

	// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
	// +optional
	sampleLimit?: uint64 @go(SampleLimit)
}

// VMServiceScrapeStatus defines the observed state of VMServiceScrape
#VMServiceScrapeStatus: {
}

// VMServiceScrape is scrape configuration for endpoints associated with
// kubernetes service,
// it generates scrape configuration for vmagent based on selectors.
// result config will scrape service endpoints
// +operator-sdk:gen-csv:customresourcedefinitions.displayName="VMServiceScrape"
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=vmservicescrapes,scope=Namespaced
// +genclient
#VMServiceScrape: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta     @go(ObjectMeta)
	spec:      #VMServiceScrapeSpec   @go(Spec)
	status?:   #VMServiceScrapeStatus @go(Status)
}

// VMServiceScrapeList contains a list of VMServiceScrape
#VMServiceScrapeList: {
	metav1.#TypeMeta

	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VMServiceScrape] @go(Items,[]VMServiceScrape)
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// +k8s:openapi-gen=true
#NamespaceSelector: {
	// Boolean describing whether all namespaces are selected in contrast to a
	// list restricting them.
	// +optional
	any?: bool @go(Any)

	// List of namespace names.
	// +optional
	matchNames?: [...string] @go(MatchNames,[]string)
}

_#nsMatcher: _

// Endpoint defines a scrapeable endpoint serving Prometheus metrics.
// +k8s:openapi-gen=true
#Endpoint: {
	// Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
	// +optional
	port?: string @go(Port)

	// Name or number of the pod port this endpoint refers to. Mutually exclusive with port.
	// +optional
	targetPort?: null | intstr.#IntOrString @go(TargetPort,*intstr.IntOrString)

	// HTTP path to scrape for metrics.
	// +optional
	path?: string @go(Path)

	// HTTP scheme to use for scraping.
	// +optional
	// +kubebuilder:validation:Enum=http;https
	scheme?: string @go(Scheme)

	// Optional HTTP URL parameters
	// +optional
	params?: {[string]: [...string]} @go(Params,map[string][]string)

	// FollowRedirects controls redirects for scraping.
	// +optional
	follow_redirects?: null | bool @go(FollowRedirects,*bool)

	// Interval at which metrics should be scraped
	// +optional
	interval?: string @go(Interval)

	// ScrapeInterval is the same as Interval and has priority over it.
	// one of scrape_interval or interval can be used
	// +optional
	scrape_interval?: string @go(ScrapeInterval)

	// Timeout after which the scrape is ended
	// +optional
	scrapeTimeout?: string @go(ScrapeTimeout)

	// SampleLimit defines per-endpoint limit on number of scraped samples that will be accepted.
	// +optional
	sampleLimit?: uint64 @go(SampleLimit)

	// OAuth2 defines auth configuration
	// +optional
	oauth2?: null | #OAuth2 @go(OAuth2,*OAuth2)

	// Authorization with http header Authorization
	// +optional
	authorization?: null | #Authorization @go(Authorization,*Authorization)

	// TLSConfig configuration to use when scraping the endpoint
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// File to read bearer token for scraping targets.
	// +optional
	bearerTokenFile?: string @go(BearerTokenFile)

	// Secret to mount to read bearer token for scraping targets. The secret
	// needs to be in the same namespace as the service scrape and accessible by
	// the victoria-metrics operator.
	// +optional
	// +nullable
	bearerTokenSecret?: null | v1.#SecretKeySelector @go(BearerTokenSecret,*v1.SecretKeySelector)

	// HonorLabels chooses the metric's labels on collisions with target labels.
	// +optional
	honorLabels?: bool @go(HonorLabels)

	// HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
	// +optional
	honorTimestamps?: null | bool @go(HonorTimestamps,*bool)

	// BasicAuth allow an endpoint to authenticate over basic authentication
	// More info: https://prometheus.io/docs/operating/configuration/#endpoints
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// MetricRelabelConfigs to apply to samples before ingestion.
	// +optional
	metricRelabelConfigs?: [...null | #RelabelConfig] @go(MetricRelabelConfigs,[]*RelabelConfig)

	// RelabelConfigs to apply to samples before scraping.
	// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
	// +optional
	relabelConfigs?: [...null | #RelabelConfig] @go(RelabelConfigs,[]*RelabelConfig)

	// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
	// +optional
	proxyURL?: null | string @go(ProxyURL,*string)

	// VMScrapeParams defines VictoriaMetrics specific scrape parametrs
	// +optional
	vm_scrape_params?: null | #VMScrapeParams @go(VMScrapeParams,*VMScrapeParams)

	// AttachMetadata configures metadata attaching from service discovery
	// +optional
	attach_metadata?: #AttachMetadata @go(AttachMetadata)
}

// AttachMetadata configures metadata attachment
#AttachMetadata: {
	// Node instructs vmagent to add node specific metadata from service discovery
	// Valid for roles: pod, endpoints, endpointslice.
	// +optional
	node?: null | bool @go(Node,*bool)
}

// VMScrapeParams defines scrape target configuration that compatible only with VictoriaMetrics scrapers
// VMAgent and VMSingle
#VMScrapeParams: {
	// +optional
	relabel_debug?: null | bool @go(RelabelDebug,*bool)

	// +optional
	metric_relabel_debug?: null | bool @go(MetricRelabelDebug,*bool)

	// +optional
	disable_compression?: null | bool @go(DisableCompression,*bool)

	// +optional
	disable_keep_alive?: null | bool @go(DisableKeepAlive,*bool)

	// +optional
	no_stale_markers?: null | bool @go(DisableStaleMarkers,*bool)

	// +optional
	stream_parse?: null | bool @go(StreamParse,*bool)

	// +optional
	scrape_align_interval?: null | string @go(ScrapeAlignInterval,*string)

	// +optional
	scrape_offset?: null | string @go(ScrapeOffset,*string)

	// ProxyClientConfig configures proxy auth settings for scraping
	// See feature description https://docs.victoriametrics.com/vmagent.html#scraping-targets-via-a-proxy
	// +optional
	proxy_client_config?: null | #ProxyAuth @go(ProxyClientConfig,*ProxyAuth)

	// Headers allows sending custom headers to scrape targets
	// must be in of semicolon separated header with it's value
	// eg:
	// headerName: headerValue
	// vmagent supports since 1.79.0 version
	// +optional
	headers?: [...string] @go(Headers,[]string)
}

// ProxyAuth represent proxy auth config
// Only VictoriaMetrics scrapers supports it.
// See https://github.com/VictoriaMetrics/VictoriaMetrics/commit/a6a71ef861444eb11fe8ec6d2387f0fc0c4aea87
#ProxyAuth: {
	basic_auth?:        null | #BasicAuth            @go(BasicAuth,*BasicAuth)
	bearer_token?:      null | v1.#SecretKeySelector @go(BearerToken,*v1.SecretKeySelector)
	bearer_token_file?: string                       @go(BearerTokenFile)
	tls_config?:        null | #TLSConfig            @go(TLSConfig,*TLSConfig)
}

// OAuth2 defines OAuth2 configuration
#OAuth2: {
	// The secret or configmap containing the OAuth2 client id
	// +required
	client_id: #SecretOrConfigMap @go(ClientID)

	// The secret containing the OAuth2 client secret
	// +optional
	client_secret?: null | v1.#SecretKeySelector @go(ClientSecret,*v1.SecretKeySelector)

	// ClientSecretFile defines path for client secret file.
	// +optional
	client_secret_file?: string @go(ClientSecretFile)

	// The URL to fetch the token from
	// +kubebuilder:validation:MinLength=1
	// +required
	token_url: string @go(TokenURL)

	// OAuth2 scopes used for the token request
	// +optional
	scopes?: [...string] @go(Scopes,[]string)

	// Parameters to append to the token URL
	// +optional
	endpoint_params?: {[string]: string} @go(EndpointParams,map[string]string)
}

// Authorization configures generic authorization params
#Authorization: {
	// Type of authorization, default to bearer
	// +optional
	type?: string @go(Type)

	// Reference to the secret with value for authorization
	credentials?: null | v1.#SecretKeySelector @go(Credentials,*v1.SecretKeySelector)

	// File with value for authorization
	// +optional
	credentialsFile?: string @go(CredentialsFile)
}

// TLSConfig specifies TLSConfig configuration parameters.
// +k8s:openapi-gen=true
#TLSConfig: {
	// Path to the CA cert in the container to use for the targets.
	// +optional
	caFile?: string @go(CAFile)

	// Stuct containing the CA cert to use for the targets.
	// +optional
	ca?: #SecretOrConfigMap @go(CA)

	// Path to the client cert file in the container for the targets.
	// +optional
	certFile?: string @go(CertFile)

	// Struct containing the client cert file for the targets.
	// +optional
	cert?: #SecretOrConfigMap @go(Cert)

	// Path to the client key file in the container for the targets.
	// +optional
	keyFile?: string @go(KeyFile)

	// Secret containing the client key file for the targets.
	// +optional
	keySecret?: null | v1.#SecretKeySelector @go(KeySecret,*v1.SecretKeySelector)

	// Used to verify the hostname for the targets.
	// +optional
	serverName?: string @go(ServerName)

	// Disable target certificate validation.
	// +optional
	insecureSkipVerify?: bool @go(InsecureSkipVerify)
}

// SecretOrConfigMap allows to specify data as a Secret or ConfigMap. Fields are mutually exclusive.
#SecretOrConfigMap: {
	// Secret containing data to use for the targets.
	// +optional
	secret?: null | v1.#SecretKeySelector @go(Secret,*v1.SecretKeySelector)

	// ConfigMap containing data to use for the targets.
	// +optional
	configMap?: null | v1.#ConfigMapKeySelector @go(ConfigMap,*v1.ConfigMapKeySelector)
}

// RelabelConfig allows dynamic rewriting of the label set, being applied to samples before ingestion.
// It defines `<metric_relabel_configs>`-section of configuration.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#metric_relabel_configs
// +k8s:openapi-gen=true
#RelabelConfig: _

// APIServerConfig defines a host and auth methods to access apiserver.
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
// +k8s:openapi-gen=true
#APIServerConfig: {
	// Host of apiserver.
	// A valid string consisting of a hostname or IP followed by an optional port number
	host: string @go(Host)

	// BasicAuth allow an endpoint to authenticate over basic authentication
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// Bearer token for accessing apiserver.
	// +optional
	bearerToken?: string @go(BearerToken)

	// File to read bearer token for accessing apiserver.
	// +optional
	bearerTokenFile?: string @go(BearerTokenFile)

	// TLSConfig Config to use for accessing apiserver.
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// +optional
	authorization?: null | #Authorization @go(Authorization,*Authorization)
}
